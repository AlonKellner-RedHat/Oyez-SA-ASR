# Generated by Claude
"""Term parsing with support for ranges, abbreviations, and comma-separated lists.

Examples
--------
    "1998" → ["1998"]
    "98" → ["1998"]
    "98-00" → ["1998", "1999", "2000"]
    "2020-22" → ["2020", "2021", "2022"]
    "98-00,22" → ["1998", "1999", "2000", "2022"]
    "1998,99-00,2022" → ["1998", "1999", "2000", "2022"]
"""

# Valid year range for Supreme Court terms
_MIN_YEAR = 1850
_MAX_YEAR = 2100


def expand_abbreviation(abbr: str) -> str:
    """Expand 2-digit year abbreviation to 4-digit year.

    Rules:
    - 00-50 → 2000-2050
    - 51-99 → 1951-1999

    Args:
        abbr: 2-digit year string (e.g., "98", "22")

    Returns
    -------
        4-digit year string (e.g., "1998", "2022")

    Raises
    ------
        ValueError: If abbreviation is invalid
    """
    if not abbr.isdigit():
        raise ValueError(f"Invalid year abbreviation: {abbr}")

    if len(abbr) == 4:
        # Already a full year
        year = int(abbr)
        if year < _MIN_YEAR or year > _MAX_YEAR:
            raise ValueError(
                f"Year {year} out of valid range [{_MIN_YEAR}, {_MAX_YEAR}]"
            )
        return abbr

    if len(abbr) != 2:
        raise ValueError(f"Year abbreviation must be 2 or 4 digits: {abbr}")

    num = int(abbr)
    # 00-50 → 2000-2050, 51-99 → 1951-1999
    year = 2000 + num if num <= 50 else 1900 + num

    if year < _MIN_YEAR or year > _MAX_YEAR:
        raise ValueError(
            f"Expanded year {year} out of valid range [{_MIN_YEAR}, {_MAX_YEAR}]"
        )

    return str(year)


def parse_range(range_str: str) -> list[str]:
    """Parse a year range string.

    Args:
        range_str: Range string like "98-00" or "2020-22"

    Returns
    -------
        List of year strings in the range (inclusive)

    Raises
    ------
        ValueError: If range is invalid

    Examples
    --------
        "98-00" → ["1998", "1999", "2000"]
        "2020-22" → ["2020", "2021", "2022"]
        "99-01" → ["1999", "2000", "2001"] (cross-century)
    """
    parts = range_str.split("-", 1)
    if len(parts) != 2:
        raise ValueError(f"Invalid range format: {range_str}")

    start_str, end_str = parts[0].strip(), parts[1].strip()

    # Expand abbreviations
    start_year = int(expand_abbreviation(start_str))
    end_year = int(expand_abbreviation(end_str))

    # Handle cross-century ranges (e.g., 99-01)
    if end_year < start_year:
        # Assume we're crossing century boundary
        # e.g., 99-01 means 1999-2001, not 1999-1901
        if start_year < 2000 and end_year < 2000:
            # Both in 1900s, but end < start means wrap to 2000s
            end_year = 2000 + (end_year % 100)
        elif start_year >= 2000:
            # Start in 2000s, end must be in next century
            end_year = 2000 + (end_year % 100)

    if start_year > end_year:
        raise ValueError(f"Invalid range: start ({start_year}) > end ({end_year})")

    if end_year - start_year > 100:
        raise ValueError(f"Range too large: {end_year - start_year} years")

    years = []
    for year in range(start_year, end_year + 1):
        if year < _MIN_YEAR or year > _MAX_YEAR:
            continue  # Skip out-of-range years
        years.append(str(year))

    if not years:
        raise ValueError(f"No valid years in range {range_str}")

    return years


def parse_terms(term_string: str) -> list[str]:
    """Parse term string with ranges, abbreviations, and comma-separated values.

    Args:
        term_string: Term string like "98-00,22" or "1998,99-00,2022"

    Returns
    -------
        Sorted list of unique 4-digit year strings

    Raises
    ------
        ValueError: If term string is invalid

    Examples
    --------
        "1998" → ["1998"]
        "98" → ["1998"]
        "98-00" → ["1998", "1999", "2000"]
        "2020-22" → ["2020", "2021", "2022"]
        "98-00,22" → ["1998", "1999", "2000", "2022"]
        "1998,99-00,2022" → ["1998", "1999", "2000", "2022"]
    """
    if not term_string or not term_string.strip():
        raise ValueError("Empty term string")

    years: set[str] = set()

    # Split by comma
    parts = [p.strip() for p in term_string.split(",") if p.strip()]

    for part in parts:
        if "-" in part:
            # Parse as range
            range_years = parse_range(part)
            years.update(range_years)
        else:
            # Parse as single term
            year = expand_abbreviation(part)
            years.add(year)

    # Return sorted list
    return sorted(years)


def parse_term_list(term_list: list[str] | None) -> list[str] | None:
    """Parse a list of term strings, each potentially containing ranges/abbreviations.

    Args:
        term_list: List of term strings (e.g., ["98-00", "22"] or ["1998", "99-00,22"])

    Returns
    -------
        Sorted list of unique 4-digit year strings, or None if input is None/empty
    """
    if not term_list:
        return None

    all_years: set[str] = set()

    for term_str in term_list:
        parsed = parse_terms(term_str)
        all_years.update(parsed)

    return sorted(all_years) if all_years else None
