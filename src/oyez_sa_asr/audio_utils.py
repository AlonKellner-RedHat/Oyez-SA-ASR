# Generated by Claude
"""Audio I/O utilities using PyAV (ffmpeg bindings).

Supports loading and saving audio in various formats:
- FLAC (lossless, 24-bit)
- MP3 (lossy)
- OGG/Vorbis (lossy)
- HLS/M3U8 streaming URLs (load only)
"""

from pathlib import Path
from typing import NamedTuple

import av
import numpy as np
from numpy.typing import NDArray


class _CodecConfig(NamedTuple):
    """Configuration for an audio codec."""

    codec_name: str
    sample_fmt: str
    scale: float


class AudioMetadata(NamedTuple):
    """Audio file metadata."""

    format: str
    sample_rate: int
    channels: int
    duration: float
    bitrate: int | None
    file_size: int


def get_audio_metadata(path: Path | str) -> dict[str, int | float | str | None]:
    """Extract metadata from an audio file.

    Args:
        path: Path to the audio file.

    Returns
    -------
        Dictionary with keys: format, sample_rate, channels, duration,
        bitrate, file_size.
    """
    path = Path(path)
    file_size = path.stat().st_size

    with av.open(str(path)) as container:
        stream = container.streams.audio[0]
        # Get format from container format name
        fmt = container.format.name or path.suffix.lstrip(".").lower()
        sample_rate: int = stream.rate
        channels: int = stream.codec_context.channels
        # Duration in seconds
        duration = float(container.duration) / 1_000_000 if container.duration else 0.0
        # Bitrate (may be None for some formats)
        bitrate = stream.codec_context.bit_rate

    return {
        "format": fmt,
        "sample_rate": sample_rate,
        "channels": channels,
        "duration": duration,
        "bitrate": bitrate,
        "file_size": file_size,
    }


# Codec configurations for supported formats
_CODEC_CONFIGS: dict[str, _CodecConfig] = {
    "mp3": _CodecConfig("libmp3lame", "fltp", 1.0),
    "ogg": _CodecConfig("libvorbis", "fltp", 1.0),
    "wav": _CodecConfig("pcm_s16le", "s16", 32767.0),
}


def _get_codec_config(fmt: str, bits_per_sample: int) -> _CodecConfig:
    """Get codec configuration for a format."""
    if fmt == "flac":
        if bits_per_sample == 24:
            return _CodecConfig("flac", "s32", 2147483647.0)
        return _CodecConfig("flac", "s16", 32767.0)
    if fmt in _CODEC_CONFIGS:
        return _CODEC_CONFIGS[fmt]
    raise ValueError(f"Unsupported format: {fmt}")


def _normalize_audio(audio: NDArray[np.generic]) -> NDArray[np.float32]:
    """Convert audio to float32 in [-1, 1] range."""
    if audio.dtype == np.int16:
        return audio.astype(np.float32) / 32768.0
    if audio.dtype == np.int32:
        return audio.astype(np.float32) / 2147483648.0
    return audio.astype(np.float32)


def load_audio(path: Path | str) -> tuple[NDArray[np.float32], int]:
    """Load audio from file or URL.

    Supports FLAC, MP3, OGG, WAV, and HLS/M3U8 streaming URLs.

    Args:
        path: Path to audio file or URL (including HLS/M3U8 streams).

    Returns
    -------
        Tuple of (samples, sample_rate) where samples is a numpy array
        of shape (channels, num_samples) with dtype float32 in range [-1, 1].
    """
    path_str = str(path)

    with av.open(path_str) as container:
        stream = container.streams.audio[0]
        sample_rate: int = stream.rate
        num_channels: int = stream.codec_context.channels
        is_planar: bool = stream.format.is_planar

        frames = [frame.to_ndarray() for frame in container.decode(audio=0)]

        if not frames:
            return np.zeros((1, 0), dtype=np.float32), sample_rate

        # PyAV to_ndarray() returns (channels, samples) shape
        audio = np.concatenate(frames, axis=1)

        # For interleaved formats with multiple channels, reshape
        if not is_planar and num_channels > 1:
            total_samples = audio.shape[1] // num_channels
            audio = audio.reshape(-1).reshape(total_samples, num_channels).T

        return _normalize_audio(audio), sample_rate


def save_audio(
    samples: NDArray[np.floating],
    sample_rate: int,
    path: Path | str,
    format: str | None = None,
    bits_per_sample: int = 24,
) -> None:
    """Save audio to file.

    Args:
        samples: Audio samples as numpy array. Can be 1D (mono) or 2D.
            If 2D, shape should be (channels, num_samples).
            Values should be in range [-1, 1].
        sample_rate: Sample rate in Hz.
        path: Output file path. Format is inferred from extension if not specified.
        format: Audio format ('flac', 'mp3', 'ogg'). If None, inferred from path.
        bits_per_sample: Bit depth for FLAC (16 or 24). Default is 24.
    """
    path = Path(path)
    if format is None:
        format = path.suffix.lstrip(".").lower()

    # Ensure samples is 2D: (channels, samples)
    if samples.ndim == 1:
        samples = samples[np.newaxis, :]

    channels = samples.shape[0]
    num_samples = samples.shape[1]
    samples = np.clip(samples, -1.0, 1.0).astype(np.float32)

    config = _get_codec_config(format, bits_per_sample)
    layout = "mono" if channels == 1 else "stereo"

    with av.open(str(path), mode="w") as container:
        stream = container.add_stream(config.codec_name, rate=sample_rate)
        # Cast to AudioStream for type checking (add_stream returns union type)
        audio_stream: av.AudioStream = stream  # type: ignore[assignment]
        audio_stream.layout = layout
        audio_stream.format = config.sample_fmt

        frame_size = 4096
        for start in range(0, num_samples, frame_size):
            chunk = samples[:, start : min(start + frame_size, num_samples)]
            frame = av.AudioFrame(
                format=config.sample_fmt,
                layout=audio_stream.layout,
                samples=chunk.shape[1],
            )
            frame.rate = sample_rate

            _write_frame_data(frame, chunk, config)
            for packet in audio_stream.encode(frame):
                container.mux(packet)

        for packet in audio_stream.encode():
            container.mux(packet)


def _write_frame_data(
    frame: av.AudioFrame, chunk: NDArray[np.float32], config: _CodecConfig
) -> None:
    """Write audio data to frame planes."""
    if config.sample_fmt in ("s16", "s32"):
        dtype = np.int16 if "16" in config.sample_fmt else np.int32
        scaled = chunk.astype(np.float64) * config.scale
        scaled = np.clip(scaled, np.iinfo(dtype).min, np.iinfo(dtype).max)
        int_samples = scaled.astype(dtype).T.flatten()
        frame.planes[0].update(int_samples.tobytes())
    else:
        for i, plane in enumerate(frame.planes):
            plane.update(chunk[i].astype(np.float32).tobytes())
