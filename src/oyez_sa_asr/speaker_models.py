# Generated by Claude
"""Speaker profile data models for aggregating speaker statistics."""

import json
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

# Thresholds for automatic justice detection
# Real justices appear in 400+ cases across many terms
# Frequent advocates (like Solicitors General) max out around 100 cases
MIN_CASES_FOR_JUSTICE = 200
MIN_TERMS_FOR_JUSTICE = 5


def slugify_name(name: str) -> str:
    """Convert speaker name to a URL-safe slug.

    Args:
        name: Speaker name like "John G. Roberts, Jr."

    Returns
    -------
        Slugified name like "john_g_roberts_jr"
    """
    if not name:
        return ""
    # Remove special characters except spaces
    slug = re.sub(r"[^\w\s]", "", name)
    # Replace spaces with underscores and collapse multiples
    slug = re.sub(r"\s+", "_", slug.strip())
    return slug.lower()


@dataclass
class TermStats:
    """Statistics for a speaker within a single term."""

    recordings: int = 0
    turns: int = 0
    duration_seconds: float = 0.0
    word_count: int = 0

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "recordings": self.recordings,
            "turns": self.turns,
            "duration_seconds": round(self.duration_seconds, 2),
            "word_count": self.word_count,
        }


@dataclass
class RecordingAppearance:
    """A speaker's appearance in a single recording."""

    term: str
    docket: str
    case_name: str
    transcript_type: str
    turns: int
    duration_seconds: float
    word_count: int

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "term": self.term,
            "docket": self.docket,
            "case_name": self.case_name,
            "transcript_type": self.transcript_type,
            "turns": self.turns,
            "duration_seconds": round(self.duration_seconds, 2),
            "word_count": self.word_count,
        }


@dataclass
class SpeakerProfile:
    """Aggregated profile for a speaker across all recordings."""

    id: int
    name: str
    name_slug: str = field(init=False)
    role: str = field(init=False, default="other")
    first_appearance: str | None = None
    last_appearance: str | None = None
    recordings: list[RecordingAppearance] = field(default_factory=list)
    cases: set[str] = field(default_factory=set)
    _term_stats: dict[str, TermStats] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Initialize derived fields."""
        self.name_slug = slugify_name(self.name)
        # Role will be determined after all appearances are added

    def add_appearance(
        self,
        term: str,
        docket: str,
        case_name: str,
        transcript_type: str,
        turns: int,
        duration_seconds: float,
        word_count: int,
    ) -> None:
        """Add a recording appearance for this speaker."""
        appearance = RecordingAppearance(
            term=term,
            docket=docket,
            case_name=case_name,
            transcript_type=transcript_type,
            turns=turns,
            duration_seconds=duration_seconds,
            word_count=word_count,
        )
        self.recordings.append(appearance)
        self.cases.add(f"{term}/{docket}")

        # Update term stats
        if term not in self._term_stats:
            self._term_stats[term] = TermStats()
        stats = self._term_stats[term]
        stats.recordings += 1
        stats.turns += turns
        stats.duration_seconds += duration_seconds
        stats.word_count += word_count

    def update_appearance_dates(self, date_str: str) -> None:
        """Update first/last appearance dates."""
        if not date_str:
            return

        if self.first_appearance is None or date_str < self.first_appearance:
            self.first_appearance = date_str
        if self.last_appearance is None or date_str > self.last_appearance:
            self.last_appearance = date_str

    def detect_role(self, output_dir: Path | None = None) -> str:
        """Detect role based on appearance patterns.

        Justices appear in many cases across multiple terms.
        Advocates typically appear in just a few cases.

        If output_dir is provided, checks for existing justice files to preserve
        justice status even when processing term-filtered subsets.

        Args:
            output_dir: Optional directory to check for existing justice files.

        Returns
        -------
            "justice" if speaker meets thresholds or has existing justice file, otherwise "other"
        """
        # Edited by Claude: Check for existing justice file first
        # This ensures justices are always recognized regardless of term scope
        if output_dir is not None:
            justices_dir = output_dir / "justices"
            if justices_dir.exists():
                # Check if any file with this speaker_id exists in justices directory
                for _existing_file in justices_dir.glob(f"{self.id}_*.json"):
                    # Found existing justice file - preserve justice status
                    return "justice"

        num_cases = len(self.cases)
        num_terms = len(self._term_stats)

        if num_cases >= MIN_CASES_FOR_JUSTICE and num_terms >= MIN_TERMS_FOR_JUSTICE:
            return "justice"
        return "other"

    def finalize(self, output_dir: Path | None = None) -> None:
        """Finalize the profile after all appearances have been added.

        This determines the role based on collected data.
        If output_dir is provided, checks for existing justice files to preserve status.

        Args:
            output_dir: Optional directory to check for existing justice files.
        """
        self.role = self.detect_role(output_dir)

    def get_totals(self) -> dict[str, Any]:
        """Get aggregated totals across all recordings."""
        total_turns = sum(r.turns for r in self.recordings)
        total_words = sum(r.word_count for r in self.recordings)
        total_duration = sum(r.duration_seconds for r in self.recordings)

        avg_words = total_words / total_turns if total_turns > 0 else 0.0

        return {
            "recordings": len(self.recordings),
            "cases": len(self.cases),
            "turns": total_turns,
            "duration_seconds": round(total_duration, 2),
            "word_count": total_words,
            "avg_words_per_turn": round(avg_words, 1),
        }

    def get_by_term(self) -> dict[str, dict[str, Any]]:
        """Get statistics broken down by term."""
        return {term: stats.to_dict() for term, stats in self._term_stats.items()}

    def get_filename(self) -> str:
        """Get the filename for this speaker's JSON file."""
        return f"{self.id}_{self.name_slug}.json"

    def get_subdir(self) -> str:
        """Get the subdirectory for this speaker based on role."""
        return "justices" if self.role == "justice" else "other"

    def to_dict(self) -> dict[str, Any]:
        """Convert to full dictionary for JSON serialization."""
        return {
            "id": self.id,
            "name": self.name,
            "name_slug": self.name_slug,
            "role": self.role,
            "first_appearance": self.first_appearance,
            "last_appearance": self.last_appearance,
            "totals": self.get_totals(),
            "by_term": self.get_by_term(),
            "recordings": [r.to_dict() for r in self.recordings],
            "cases": sorted(self.cases),
        }

    def save(self, output_dir: Path) -> Path:
        """Save speaker profile to JSON file in role-based subdirectory.

        Automatically finalizes the profile (detects role) before saving.
        Checks for existing justice files to preserve justice status.

        Edited by Claude: Pass output_dir to finalize() to check for existing justice files.
        """
        self.finalize(output_dir)
        subdir = output_dir / self.get_subdir()
        subdir.mkdir(parents=True, exist_ok=True)
        output_path = subdir / self.get_filename()

        # If moving from other/ to justices/, remove old file
        other_path = output_dir / "other" / self.get_filename()
        if other_path.exists() and self.role == "justice":
            other_path.unlink()

        with output_path.open("w") as f:
            json.dump(self.to_dict(), f, indent=2)
        return output_path
