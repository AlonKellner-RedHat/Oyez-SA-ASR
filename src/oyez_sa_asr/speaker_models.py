# Generated by Claude
"""Speaker profile data models for aggregating speaker statistics."""

import json
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any


def slugify_name(name: str) -> str:
    """Convert speaker name to a URL-safe slug.

    Args:
        name: Speaker name like "John G. Roberts, Jr."

    Returns
    -------
        Slugified name like "john_g_roberts_jr"
    """
    if not name:
        return ""
    # Remove special characters except spaces
    slug = re.sub(r"[^\w\s]", "", name)
    # Replace spaces with underscores and collapse multiples
    slug = re.sub(r"\s+", "_", slug.strip())
    return slug.lower()


def detect_role(name: str) -> str:
    """Detect speaker role from name.

    Args:
        name: Speaker name like "Chief Justice John G. Roberts, Jr."

    Returns
    -------
        Role: "chief_justice", "justice", "advocate", or "unknown"
    """
    name_lower = name.lower()

    if name_lower.startswith("chief justice"):
        return "chief_justice"
    if name_lower.startswith("justice"):
        return "justice"
    if name_lower.startswith(("mr.", "ms.", "mrs.")):
        return "advocate"

    return "unknown"


@dataclass
class TermStats:
    """Statistics for a speaker within a single term."""

    recordings: int = 0
    turns: int = 0
    duration_seconds: float = 0.0
    word_count: int = 0

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "recordings": self.recordings,
            "turns": self.turns,
            "duration_seconds": round(self.duration_seconds, 2),
            "word_count": self.word_count,
        }


@dataclass
class RecordingAppearance:
    """A speaker's appearance in a single recording."""

    term: str
    docket: str
    case_name: str
    transcript_type: str
    turns: int
    duration_seconds: float
    word_count: int

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "term": self.term,
            "docket": self.docket,
            "case_name": self.case_name,
            "transcript_type": self.transcript_type,
            "turns": self.turns,
            "duration_seconds": round(self.duration_seconds, 2),
            "word_count": self.word_count,
        }


@dataclass
class SpeakerProfile:
    """Aggregated profile for a speaker across all recordings."""

    id: int
    name: str
    name_slug: str = field(init=False)
    role: str = field(init=False)
    first_appearance: str | None = None
    last_appearance: str | None = None
    recordings: list[RecordingAppearance] = field(default_factory=list)
    cases: set[str] = field(default_factory=set)
    _term_stats: dict[str, TermStats] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Initialize derived fields."""
        self.name_slug = slugify_name(self.name)
        self.role = detect_role(self.name)

    def add_appearance(
        self,
        term: str,
        docket: str,
        case_name: str,
        transcript_type: str,
        turns: int,
        duration_seconds: float,
        word_count: int,
    ) -> None:
        """Add a recording appearance for this speaker."""
        appearance = RecordingAppearance(
            term=term,
            docket=docket,
            case_name=case_name,
            transcript_type=transcript_type,
            turns=turns,
            duration_seconds=duration_seconds,
            word_count=word_count,
        )
        self.recordings.append(appearance)
        self.cases.add(f"{term}/{docket}")

        # Update term stats
        if term not in self._term_stats:
            self._term_stats[term] = TermStats()
        stats = self._term_stats[term]
        stats.recordings += 1
        stats.turns += turns
        stats.duration_seconds += duration_seconds
        stats.word_count += word_count

    def update_appearance_dates(self, date_str: str) -> None:
        """Update first/last appearance dates."""
        if not date_str:
            return

        if self.first_appearance is None or date_str < self.first_appearance:
            self.first_appearance = date_str
        if self.last_appearance is None or date_str > self.last_appearance:
            self.last_appearance = date_str

    def get_totals(self) -> dict[str, Any]:
        """Get aggregated totals across all recordings."""
        total_turns = sum(r.turns for r in self.recordings)
        total_words = sum(r.word_count for r in self.recordings)
        total_duration = sum(r.duration_seconds for r in self.recordings)

        avg_words = total_words / total_turns if total_turns > 0 else 0.0

        return {
            "recordings": len(self.recordings),
            "cases": len(self.cases),
            "turns": total_turns,
            "duration_seconds": round(total_duration, 2),
            "word_count": total_words,
            "avg_words_per_turn": round(avg_words, 1),
        }

    def get_by_term(self) -> dict[str, dict[str, Any]]:
        """Get statistics broken down by term."""
        return {term: stats.to_dict() for term, stats in self._term_stats.items()}

    def get_filename(self) -> str:
        """Get the filename for this speaker's JSON file."""
        return f"{self.id}_{self.name_slug}.json"

    def to_dict(self) -> dict[str, Any]:
        """Convert to full dictionary for JSON serialization."""
        return {
            "id": self.id,
            "name": self.name,
            "name_slug": self.name_slug,
            "role": self.role,
            "first_appearance": self.first_appearance,
            "last_appearance": self.last_appearance,
            "totals": self.get_totals(),
            "by_term": self.get_by_term(),
            "recordings": [r.to_dict() for r in self.recordings],
            "cases": sorted(self.cases),
        }

    def save(self, output_dir: Path) -> Path:
        """Save speaker profile to JSON file."""
        output_dir.mkdir(parents=True, exist_ok=True)
        output_path = output_dir / self.get_filename()
        with output_path.open("w") as f:
            json.dump(self.to_dict(), f, indent=2)
        return output_path
