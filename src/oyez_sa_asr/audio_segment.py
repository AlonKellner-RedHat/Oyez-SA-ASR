# Generated by Claude
"""Audio segment extraction for efficient utterance processing.

This module provides functions to extract audio segments and encode them
to FLAC bytes, optimized for batch processing where one file is read
once and multiple segments are extracted.
"""

import tempfile
from pathlib import Path

import numpy as np
from numpy.typing import NDArray

from .audio_utils import load_audio, save_audio


def extract_segment_from_array(
    samples: NDArray[np.float32],
    sample_rate: int,
    start_sec: float,
    end_sec: float,
    bits_per_sample: int = 16,
) -> bytes:
    """Extract a segment from an audio array and encode to FLAC bytes.

    Args:
        samples: Audio samples as numpy array, shape (channels, num_samples).
        sample_rate: Sample rate in Hz.
        start_sec: Start time in seconds.
        end_sec: End time in seconds.
        bits_per_sample: Bit depth for FLAC encoding (default 16).

    Returns
    -------
        FLAC-encoded bytes for the segment.
    """
    # Validate time range
    if start_sec >= end_sec:
        msg = f"start_sec ({start_sec}) must be < end_sec ({end_sec})"
        raise ValueError(msg)

    start_sample = int(start_sec * sample_rate)
    end_sample = int(end_sec * sample_rate)

    # Clamp to valid range
    start_sample = max(0, start_sample)
    end_sample = min(samples.shape[1], end_sample)

    # Extract segment (may be empty if times are out of bounds)
    segment = samples[:, start_sample:end_sample]

    # Encode to FLAC bytes using a temp file (PyAV requires file-like objects)
    with tempfile.NamedTemporaryFile(suffix=".flac", delete=False) as f:
        tmp_path = Path(f.name)

    try:
        save_audio(
            segment,
            sample_rate,
            tmp_path,
            format="flac",
            bits_per_sample=bits_per_sample,
        )
        return tmp_path.read_bytes()
    finally:
        tmp_path.unlink(missing_ok=True)


def extract_segment(
    audio_path: Path,
    start_sec: float,
    end_sec: float,
    bits_per_sample: int = 16,
) -> bytes:
    """Extract a segment from an audio file and return as FLAC bytes.

    Args:
        audio_path: Path to the source audio file.
        start_sec: Start time in seconds.
        end_sec: End time in seconds.
        bits_per_sample: Bit depth for FLAC encoding (default 16).

    Returns
    -------
        FLAC-encoded bytes for the segment.
    """
    samples, sample_rate = load_audio(audio_path)
    return extract_segment_from_array(
        samples, sample_rate, start_sec, end_sec, bits_per_sample
    )


def extract_segments_batch(
    audio_path: Path,
    segments: list[tuple[float, float]],
    bits_per_sample: int = 16,
) -> list[bytes]:
    """Extract multiple segments from one audio file (reads file once).

    This is the optimized function for batch processing - it loads the
    audio file once and extracts all segments from the in-memory array.

    Args:
        audio_path: Path to the source audio file.
        segments: List of (start_sec, end_sec) tuples.
        bits_per_sample: Bit depth for FLAC encoding (default 16).

    Raises
    ------
        ValueError: If any segment has start_sec >= end_sec.
        OSError: If audio file cannot be read or written.

    Returns
    -------
        List of FLAC-encoded bytes, one per segment.
    """
    if not segments:
        return []

    # Load audio ONCE
    samples, sample_rate = load_audio(audio_path)

    # Extract all segments from the loaded array
    result = []
    for start_sec, end_sec in segments:
        segment_bytes = extract_segment_from_array(
            samples, sample_rate, start_sec, end_sec, bits_per_sample
        )
        result.append(segment_bytes)

    return result
