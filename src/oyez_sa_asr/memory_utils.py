# Edited by Claude
"""Memory monitoring utilities for detecting OOM conditions."""

import ctypes
import logging
import signal
import subprocess
from pathlib import Path

logger = logging.getLogger(__name__)

# Linux prctl constant for parent death signal
_PR_SET_PDEATHSIG = 1

# Track OOM kills from cgroup
_OOM_EVENTS_PATH = Path("/sys/fs/cgroup/memory.events")


def set_pdeathsig() -> None:
    """Set worker to receive SIGKILL when parent dies (Linux only).

    This function should be used as an initializer for ProcessPoolExecutor
    to ensure worker processes are automatically killed when the main process
    dies (e.g., from OOM). Generated by Claude.
    """
    try:
        libc = ctypes.CDLL("libc.so.6", use_errno=True)
        result = libc.prctl(_PR_SET_PDEATHSIG, signal.SIGKILL, 0, 0, 0)
        if result != 0:
            logger.warning("prctl(PR_SET_PDEATHSIG) failed with result %d", result)
    except OSError as e:
        # Not on Linux or libc not available
        logger.debug("set_pdeathsig unavailable: %s", e)


def get_oom_kill_count() -> int:
    """Get current OOM kill count from cgroup."""
    try:
        if _OOM_EVENTS_PATH.exists():
            content = _OOM_EVENTS_PATH.read_text()
            for line in content.splitlines():
                if line.startswith("oom_kill "):
                    return int(line.split()[1])
    except (OSError, ValueError, IndexError):
        pass
    return 0


def get_memory_usage_mb() -> tuple[int, int, int]:
    """Get memory usage (used_mb, available_mb, total_mb)."""
    try:
        result = subprocess.run(
            ["/usr/bin/free", "-m"],
            capture_output=True,
            text=True,
            check=True,
        )
        for line in result.stdout.splitlines():
            if line.startswith("Mem:"):
                parts = line.split()
                total = int(parts[1])
                used = int(parts[2])
                available = int(parts[6]) if len(parts) > 6 else total - used
                return used, available, total
    except (subprocess.SubprocessError, ValueError, IndexError, FileNotFoundError):
        pass
    return 0, 0, 0


def get_swap_usage_mb() -> tuple[int, int]:
    """Get swap usage (used_mb, total_mb). Edited by Claude."""
    try:
        result = subprocess.run(
            ["/usr/bin/free", "-m"],
            capture_output=True,
            text=True,
            check=True,
        )
        for line in result.stdout.splitlines():
            if line.startswith("Swap:"):
                parts = line.split()
                total = int(parts[1])
                used = int(parts[2])
                return used, total
    except (subprocess.SubprocessError, ValueError, IndexError, FileNotFoundError):
        pass
    return 0, 0


def kill_orphan_workers() -> int:
    """Kill orphaned multiprocessing workers from previous runs.

    Targets forkserver, resource_tracker, and semaphore_tracker processes
    that may remain after a crash or OOM kill. Edited by Claude.
    """
    killed = 0
    patterns = [
        "multiprocessing.forkserver",
        "multiprocessing.resource_tracker",
        "multiprocessing.semaphore_tracker",
    ]
    for pattern in patterns:
        try:
            # S603: patterns are hardcoded constants, not user input
            result = subprocess.run(  # noqa: S603
                ["/usr/bin/pkill", "-f", pattern],
                capture_output=True,
                check=False,
            )
            # pkill returns 0 if processes were killed
            if result.returncode == 0:
                killed += 1
        except (subprocess.SubprocessError, FileNotFoundError):
            pass
    if killed:
        logger.info("Cleaned up %d orphaned multiprocessing worker type(s)", killed)
    return killed


# Keep old name as alias for backward compatibility
kill_orphan_forkservers = kill_orphan_workers


def check_oom(initial_oom: int, last_path: Path | None) -> None:
    """Check if OOM kill occurred and log diagnostic info."""
    current_oom = get_oom_kill_count()
    if current_oom > initial_oom:
        new_kills = current_oom - initial_oom
        used, _, total = get_memory_usage_mb()
        logger.error(
            "DETECTED %d OOM KILL(S)! Memory: %d/%d MB. Last: %s",
            new_kills,
            used,
            total,
            last_path or "unknown",
        )
