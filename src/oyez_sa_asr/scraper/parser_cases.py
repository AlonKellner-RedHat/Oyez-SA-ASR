# Generated by Claude
"""Parser for cached Oyez case detail responses."""

import json
import re
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Any


def extract_media_urls(cases_dir: Path) -> list[str]:
    """Extract all case_media hrefs from processed case files.

    Iterates over data/cases/{term}/*.json files and collects oral_arguments
    and opinion_announcements hrefs, filtering out unavailable entries.

    Args:
        cases_dir: Directory containing processed case files.

    Returns
    -------
        List of unique media URLs to fetch.
    """
    urls: set[str] = set()

    if not cases_dir.exists():
        return []

    for term_dir in cases_dir.iterdir():
        if not term_dir.is_dir():
            continue

        for case_file in term_dir.glob("*.json"):
            try:
                with case_file.open() as f:
                    case_data = json.load(f)

                # Extract oral arguments
                for audio in case_data.get("oral_arguments", []) or []:
                    if audio.get("href") and not audio.get("unavailable"):
                        urls.add(audio["href"])

                # Extract opinion announcements
                for audio in case_data.get("opinion_announcements", []) or []:
                    if audio.get("href") and not audio.get("unavailable"):
                        urls.add(audio["href"])

            except (json.JSONDecodeError, KeyError, TypeError):
                continue

    return list(urls)


def parse_opinion_title(title: str) -> tuple[str, str | None]:
    """Parse opinion announcement title to extract type and speaker.

    Args:
        title: Opinion announcement title from API.

    Returns
    -------
        Tuple of (opinion_type, speaker_name).
        opinion_type is one of: "majority", "dissent", "concurrence".
        speaker_name is None for majority opinions.

    Examples
    --------
        "Opinion Announcement - June 30, 2023" -> ("majority", None)
        "Dissenting Opinion - Sotomayor - June 30, 2023" -> ("dissent", "Sotomayor")
        "Opinion Announcement - June 19, 2017 (Dissent by Breyer)" -> ("dissent", "Breyer")
        "Concurring Opinion - Jackson - June 27, 2024" -> ("concurrence", "Jackson")
    """
    # New format: "Dissenting Opinion - Justice - Date"
    if title.startswith("Dissenting Opinion - "):
        match = re.match(r"Dissenting Opinion - (\w+) - ", title)
        if match:
            return ("dissent", match.group(1))

    # New format: "Concurring Opinion - Justice - Date"
    if title.startswith("Concurring Opinion - "):
        match = re.match(r"Concurring Opinion - (\w+) - ", title)
        if match:
            return ("concurrence", match.group(1))

    # Old format: "Opinion Announcement - Date (Dissent by Justice)"
    dissent_match = re.search(r"\(Dissent by (\w+)\)", title)
    if dissent_match:
        return ("dissent", dissent_match.group(1))

    # Default: majority opinion (including numbered parts)
    return ("majority", None)


def _unix_to_iso(timestamp: int | None) -> str | None:
    """Convert Unix timestamp to ISO date string."""
    if timestamp is None:
        return None
    dt = datetime.fromtimestamp(timestamp, tz=timezone.utc)
    return dt.strftime("%Y-%m-%d")


@dataclass
class AudioReference:
    """Reference to an audio recording."""

    id: int
    title: str
    href: str
    unavailable: bool
    type: str  # "oral_argument", "majority", "dissent", "concurrence"
    speaker: str | None = None

    @classmethod
    def from_oral_argument(cls, raw: dict[str, Any]) -> "AudioReference":
        """Parse from oral argument audio entry."""
        return cls(
            id=raw.get("id", 0),
            title=raw.get("title", ""),
            href=raw.get("href", ""),
            unavailable=bool(raw.get("unavailable")),
            type="oral_argument",
            speaker=None,
        )

    @classmethod
    def from_opinion_announcement(cls, raw: dict[str, Any]) -> "AudioReference":
        """Parse from opinion announcement entry."""
        title = raw.get("title", "")
        opinion_type, speaker = parse_opinion_title(title)
        return cls(
            id=raw.get("id", 0),
            title=title,
            href=raw.get("href", ""),
            unavailable=bool(raw.get("unavailable")),
            type=opinion_type,
            speaker=speaker,
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "id": self.id,
            "title": self.title,
            "href": self.href,
            "unavailable": self.unavailable,
            "type": self.type,
            "speaker": self.speaker,
        }


@dataclass
class TimelineEvent:
    """A timeline event for a case."""

    event: str
    date: str | None

    @classmethod
    def from_raw(cls, raw: dict[str, Any]) -> "TimelineEvent":
        """Parse from raw API response."""
        dates = raw.get("dates", [])
        date = _unix_to_iso(dates[0]) if dates else None
        return cls(event=raw.get("event", ""), date=date)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {"event": self.event, "date": self.date}


@dataclass
class Decision:
    """Decision information for a case."""

    type: str
    winner: str | None
    majority_votes: int
    minority_votes: int

    @classmethod
    def from_raw(cls, raw: dict[str, Any]) -> "Decision":
        """Parse from raw API decision entry."""
        return cls(
            type=raw.get("decision_type", ""),
            winner=raw.get("winning_party"),
            majority_votes=raw.get("majority_vote", 0),
            minority_votes=raw.get("minority_vote", 0),
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "type": self.type,
            "winner": self.winner,
            "majority_votes": self.majority_votes,
            "minority_votes": self.minority_votes,
        }


@dataclass
class ProcessedCase:
    """Processed case data ready for audio/transcript scraping."""

    id: int
    name: str
    docket_number: str
    term: str
    href: str
    timeline: list[TimelineEvent] = field(default_factory=list)
    decision: Decision | None = None
    oral_arguments: list[AudioReference] = field(default_factory=list)
    opinion_announcements: list[AudioReference] = field(default_factory=list)

    @classmethod
    def from_raw(cls, raw: dict[str, Any]) -> "ProcessedCase":
        """Parse from raw API case detail response."""
        # Parse timeline
        timeline_raw = raw.get("timeline", []) or []
        timeline = [TimelineEvent.from_raw(t) for t in timeline_raw if t is not None]

        # Parse decision (use first if multiple)
        decisions_raw = raw.get("decisions", []) or []
        decision = Decision.from_raw(decisions_raw[0]) if decisions_raw else None

        # Parse oral arguments
        oral_raw = raw.get("oral_argument_audio", []) or []
        oral_arguments = [AudioReference.from_oral_argument(a) for a in oral_raw]

        # Parse opinion announcements
        opinion_raw = raw.get("opinion_announcement", []) or []
        opinion_announcements = [
            AudioReference.from_opinion_announcement(a) for a in opinion_raw
        ]

        return cls(
            id=raw.get("ID", 0),
            name=raw.get("name", ""),
            docket_number=raw.get("docket_number", ""),
            term=raw.get("term", ""),
            href=raw.get("href", ""),
            timeline=timeline,
            decision=decision,
            oral_arguments=oral_arguments,
            opinion_announcements=opinion_announcements,
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "id": self.id,
            "name": self.name,
            "docket_number": self.docket_number,
            "term": self.term,
            "href": self.href,
            "timeline": [t.to_dict() for t in self.timeline],
            "decision": self.decision.to_dict() if self.decision else None,
            "oral_arguments": [a.to_dict() for a in self.oral_arguments],
            "opinion_announcements": [a.to_dict() for a in self.opinion_announcements],
        }

    def save(self, output_dir: Path) -> Path:
        """Save case to JSON file.

        Args:
            output_dir: Root output directory.

        Returns
        -------
            Path to the created file.
        """
        case_dir = output_dir / self.term
        case_dir.mkdir(parents=True, exist_ok=True)
        file_path = case_dir / f"{self.docket_number}.json"
        with file_path.open("w") as f:
            json.dump(self.to_dict(), f, indent=2)
        return file_path
