# Generated by Claude
"""HTTP downloader implementation using httpx."""

import json
from contextlib import asynccontextmanager
from typing import Any

import httpx

from .cache import FileCache
from .models import FetchResult, RequestMetadata


class HttpxDownloader:
    """HTTP download backend using httpx.AsyncClient."""

    def __init__(
        self,
        cache: FileCache,
        *,
        timeout: float = 30.0,
        max_retries: int = 3,
    ) -> None:
        """Initialize the HTTP downloader.

        Args:
            cache: File cache for storing responses.
            timeout: Request timeout in seconds.
            max_retries: Maximum retry attempts for transient failures.
        """
        self.cache = cache
        self.timeout = timeout
        self.max_retries = max_retries

    def _parse_cached_response(self, raw_bytes: bytes, content_type: str) -> object:
        """Parse cached raw bytes based on content type."""
        if "json" in content_type:
            return json.loads(raw_bytes.decode("utf-8"))
        return raw_bytes

    def check_cache(self, request: RequestMetadata) -> FetchResult | None:
        """Check cache for a request, return result if cached."""
        cached = self.cache.get(request)
        if cached is None:
            return None
        content_type = cached.meta.content_type
        data = self._parse_cached_response(cached.response, content_type)
        return FetchResult(
            url=request.url,
            success=True,
            status_code=cached.status_code,
            data=data,
            raw_data=cached.response,
            content_type=content_type,
            from_cache=True,
        )

    def is_transient_failure(self, result: FetchResult) -> bool:
        """Check if failure is transient (429, 502-504, connection errors)."""
        if result.success:
            return False
        transient_codes = {429, 502, 503, 504}
        return result.status_code in transient_codes or result.status_code is None

    async def fetch(
        self, client: httpx.AsyncClient, request: RequestMetadata
    ) -> FetchResult:
        """Fetch from network only (no cache check)."""
        try:
            response = await client.request(
                method=request.method, url=request.url, headers=request.headers
            )
            response.raise_for_status()
            raw_bytes = response.content
            content_type = response.headers.get("content-type", "application/json")
            data = response.json() if "json" in content_type else raw_bytes
            result = FetchResult(
                url=request.url,
                success=True,
                status_code=response.status_code,
                data=data,
                raw_data=raw_bytes,
                content_type=content_type,
                from_cache=False,
            )
            self.cache.set(request, result)
            return result

        except httpx.HTTPStatusError as e:
            result = FetchResult(
                url=request.url,
                success=False,
                status_code=e.response.status_code,
                error=str(e),
            )
            if not self.is_transient_failure(result):
                self.cache.set(request, result)
            return result

        except httpx.RequestError as e:
            return FetchResult(url=request.url, success=False, error=str(e))

    @asynccontextmanager
    async def create_client(self) -> Any:
        """Create httpx.AsyncClient context manager."""
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            yield client
