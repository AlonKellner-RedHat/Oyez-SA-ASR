# Generated by Claude
"""Data models for processed transcripts."""

import json
from collections import Counter
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from oyez_sa_asr.audio_source import (
    extract_transcript_date,
    parse_date_from_title,
)

from .parser_transcripts import ProcessedTurn, parse_transcript_type


def _format_iso_date(t: tuple[int, int, int]) -> str:
    """Format (year, month, day) as YYYY-MM-DD."""
    y, m, d = t
    return f"{y}-{m:02d}-{d:02d}"


def _extract_audio_urls(media_files: list[dict[str, Any]] | None) -> dict[str, str]:
    """Extract audio URLs by format from media_file list."""
    urls: dict[str, str] = {}
    if not media_files:
        return urls

    for mf in media_files:
        if not mf:
            continue
        mime = mf.get("mime", "")
        href = mf.get("href", "")
        if mime == "audio/mpeg":
            urls["mp3"] = href
        elif mime == "audio/ogg":
            urls["ogg"] = href
        elif mime == "application/x-mpegURL":
            urls["hls"] = href

    return urls


@dataclass
class ProcessedTranscript:
    """A fully processed transcript with metadata and turns."""

    id: int
    case_docket: str
    term: str
    type: str
    speaker: str | None
    title: str
    metadata: dict[str, Any] = field(default_factory=dict)
    turns: list[ProcessedTurn] = field(default_factory=list)

    @classmethod
    def from_raw(
        cls, raw: dict[str, Any], term: str, docket: str
    ) -> "ProcessedTranscript":
        """Parse from raw API transcript response."""
        transcript_id = raw.get("id", 0)
        title = raw.get("title", "")
        transcript_type, speaker = parse_transcript_type(title)
        audio_urls = _extract_audio_urls(raw.get("media_file"))

        transcript_data = raw.get("transcript") or {}
        duration = transcript_data.get("duration", 0.0) or 0.0
        sections = transcript_data.get("sections") or []

        turns: list[ProcessedTurn] = []
        turn_index = 0
        prev_stop: float | None = None
        speaker_counts: Counter[int | None] = Counter()
        speaker_names: dict[int | None, str | None] = {}
        total_text_blocks = 0

        for section_index, section in enumerate(sections):
            for raw_turn in section.get("turns") or []:
                turn = ProcessedTurn.from_raw(
                    raw_turn, turn_index, section_index, prev_stop
                )
                turns.append(turn)
                prev_stop = turn.stop
                turn_index += 1
                speaker_counts[turn.speaker_id] += 1
                if turn.speaker_id is not None:
                    speaker_names[turn.speaker_id] = turn.speaker_name
                total_text_blocks += turn.text_block_count

        # Post-process: mark turns that are >50% of recording as invalid
        # (likely badly labeled opinion recordings without intermediate timestamps)
        recording_duration = max((t.stop for t in turns), default=0)
        if recording_duration > 0:
            for turn in turns:
                if turn.is_valid and turn.duration / recording_duration > 0.5:
                    # Mutate the turn to mark as invalid
                    object.__setattr__(turn, "is_valid", False)
                    object.__setattr__(
                        turn,
                        "invalid_reason",
                        f"too_long_ratio:{turn.duration / recording_duration:.1%}",
                    )

        overlap_count = sum(1 for t in turns if t.is_overlapping)
        invalid_count = sum(1 for t in turns if not t.is_valid)
        has_null_speakers = None in speaker_counts and speaker_counts[None] > 0
        total_spoken = sum(t.duration for t in turns if t.is_valid and t.duration > 0)
        spoken_pct = (total_spoken / duration * 100) if duration > 0 else 0.0

        speakers_list = [
            {"id": sid, "name": speaker_names.get(sid), "turn_count": count}
            for sid, count in speaker_counts.items()
            if sid is not None
        ]
        speakers_list.sort(key=lambda x: -x["turn_count"])

        metadata = {
            "audio_urls": audio_urls,
            "duration_seconds": duration,
            "total_spoken_seconds": round(total_spoken, 2),
            "spoken_percentage": round(spoken_pct, 1),
            "section_count": len(sections),
            "turn_count": len(turns),
            "text_block_count": total_text_blocks,
            "speakers": speakers_list,
            "has_null_speakers": has_null_speakers,
            "overlap_count": overlap_count,
            "invalid_turn_count": invalid_count,
        }

        return cls(
            id=transcript_id,
            case_docket=docket,
            term=term,
            type=transcript_type,
            speaker=speaker,
            title=title,
            metadata=metadata,
            turns=turns,
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        transcript_dict = {
            "metadata": self.metadata,
            "title": self.title,
        }
        url_date_t = extract_transcript_date(transcript_dict)
        title_date_t = parse_date_from_title(self.title)
        url_date: str | None = _format_iso_date(url_date_t) if url_date_t else None
        title_date: str | None = (
            _format_iso_date(title_date_t) if title_date_t else None
        )
        date_mismatch = (
            url_date_t is not None
            and title_date_t is not None
            and url_date_t != title_date_t
        )
        return {
            "id": self.id,
            "case_docket": self.case_docket,
            "term": self.term,
            "type": self.type,
            "speaker": self.speaker,
            "title": self.title,
            "title_date": title_date,
            "url_date": url_date,
            "date_mismatch": date_mismatch,
            "metadata": self.metadata,
            "turns": [t.to_dict() for t in self.turns],
        }

    def get_filename(self) -> str:
        """Get the filename for this transcript."""
        if self.speaker:
            return f"{self.type}_{self.speaker.lower()}.json"
        return f"{self.type}.json"

    def save(self, output_dir: Path, source_path: Path | None = None) -> Path:
        """Save transcript to JSON file.

        Args:
            output_dir: Root output directory.
            source_path: Optional path to source cache file for provenance.
        """
        case_dir = output_dir / self.term / self.case_docket
        case_dir.mkdir(parents=True, exist_ok=True)
        file_path = case_dir / self.get_filename()
        data = self.to_dict()
        if source_path:
            data["_meta"] = {"source_path": str(source_path)}
        with file_path.open("w") as f:
            json.dump(data, f, indent=2)
        return file_path
