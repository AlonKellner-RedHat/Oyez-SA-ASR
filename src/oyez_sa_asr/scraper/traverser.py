# Generated by Claude
"""Traverser for Oyez API pagination."""

from collections.abc import AsyncIterator
from typing import Any

from .fetcher import AdaptiveFetcher
from .models import FetchResult, RequestMetadata

OYEZ_API_BASE = "https://api.oyez.org"
CASES_ENDPOINT = "/cases"
DEFAULT_PER_PAGE = 1000


class OyezCasesTraverser:
    """Traverses paginated Oyez cases API.

    Generates requests page by page, stopping when empty results are returned.
    """

    def __init__(
        self,
        fetcher: AdaptiveFetcher,
        *,
        per_page: int = DEFAULT_PER_PAGE,
        max_pages: int | None = None,
    ) -> None:
        """Initialize the traverser.

        Args:
            fetcher: The fetcher to use for requests.
            per_page: Number of results per page.
            max_pages: Maximum number of pages to fetch (None for unlimited).
        """
        self.fetcher = fetcher
        self.per_page = per_page
        self.max_pages = max_pages

    def _build_url(self, page: int) -> str:
        """Build the URL for a specific page."""
        return (
            f"{OYEZ_API_BASE}{CASES_ENDPOINT}"
            f"?labels=true&page={page}&per_page={self.per_page}"
        )

    def _create_request(self, page: int) -> RequestMetadata:
        """Create a request for a specific page."""
        return RequestMetadata(url=self._build_url(page))

    async def traverse(self) -> AsyncIterator[tuple[int, FetchResult]]:
        """Traverse all pages of the cases API.

        Yields
        ------
            Tuples of (page_number, fetch_result) for each page.
        """
        page = 0

        while True:
            # Check max pages limit
            if self.max_pages is not None and page >= self.max_pages:
                break

            request = self._create_request(page)
            result = await self.fetcher.fetch_one(request)

            yield page, result

            # Stop on error or empty results
            if not result.success:
                break

            if self._is_empty_result(result.data):
                break

            page += 1

    async def fetch_all(self) -> list[dict[str, Any]]:
        """Fetch all cases from all pages.

        Returns
        -------
            Combined list of all cases from all pages.
        """
        all_cases: list[dict[str, Any]] = []

        async for page, result in self.traverse():
            if result.success and isinstance(result.data, list):
                all_cases.extend(result.data)
                print(
                    f"Page {page}: fetched {len(result.data)} cases "
                    f"(total: {len(all_cases)}, "
                    f"from_cache: {result.from_cache})"
                )
            elif not result.success:
                print(f"Page {page}: error - {result.error}")

        return all_cases

    @staticmethod
    def _is_empty_result(data: Any) -> bool:
        """Check if the result indicates no more data."""
        if data is None:
            return True
        return bool(isinstance(data, list) and len(data) == 0)
