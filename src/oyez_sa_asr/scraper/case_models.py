# Generated by Claude
"""Data models for case parsing."""

import re
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any


def parse_opinion_title(title: str) -> tuple[str, str | None]:
    """Parse opinion title to extract type and speaker."""
    if title.startswith("Dissenting Opinion - "):
        match = re.match(r"Dissenting Opinion - (\w+) - ", title)
        if match:
            return ("dissent", match.group(1))

    if title.startswith("Concurring Opinion - "):
        match = re.match(r"Concurring Opinion - (\w+) - ", title)
        if match:
            return ("concurrence", match.group(1))

    dissent_match = re.search(r"\(Dissent by (\w+)\)", title)
    if dissent_match:
        return ("dissent", dissent_match.group(1))

    return ("majority", None)


def _unix_to_iso(timestamp: int | None) -> str | None:
    """Convert Unix timestamp to ISO date string."""
    if timestamp is None:
        return None
    dt = datetime.fromtimestamp(timestamp, tz=timezone.utc)
    return dt.strftime("%Y-%m-%d")


@dataclass
class AudioReference:
    """Reference to an audio recording."""

    id: int
    title: str
    href: str
    unavailable: bool
    type: str  # "oral_argument", "majority", "dissent", "concurrence"
    speaker: str | None = None

    @classmethod
    def from_oral_argument(cls, raw: dict[str, Any]) -> "AudioReference":
        """Parse from oral argument audio entry."""
        return cls(
            id=raw.get("id", 0),
            title=raw.get("title", ""),
            href=raw.get("href", ""),
            unavailable=bool(raw.get("unavailable")),
            type="oral_argument",
            speaker=None,
        )

    @classmethod
    def from_opinion_announcement(cls, raw: dict[str, Any]) -> "AudioReference":
        """Parse from opinion announcement entry."""
        title = raw.get("title", "")
        opinion_type, speaker = parse_opinion_title(title)
        return cls(
            id=raw.get("id", 0),
            title=title,
            href=raw.get("href", ""),
            unavailable=bool(raw.get("unavailable")),
            type=opinion_type,
            speaker=speaker,
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "id": self.id,
            "title": self.title,
            "href": self.href,
            "unavailable": self.unavailable,
            "type": self.type,
            "speaker": self.speaker,
        }


@dataclass
class TimelineEvent:
    """A timeline event for a case."""

    event: str
    date: str | None

    @classmethod
    def from_raw(cls, raw: dict[str, Any]) -> "TimelineEvent":
        """Parse from raw API response."""
        dates = raw.get("dates", [])
        date = _unix_to_iso(dates[0]) if dates else None
        return cls(event=raw.get("event", ""), date=date)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {"event": self.event, "date": self.date}


@dataclass
class Decision:
    """Decision information for a case."""

    type: str
    winner: str | None
    majority_votes: int
    minority_votes: int

    @classmethod
    def from_raw(cls, raw: dict[str, Any]) -> "Decision":
        """Parse from raw API decision entry."""
        return cls(
            type=raw.get("decision_type", ""),
            winner=raw.get("winning_party"),
            majority_votes=raw.get("majority_vote", 0),
            minority_votes=raw.get("minority_vote", 0),
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "type": self.type,
            "winner": self.winner,
            "majority_votes": self.majority_votes,
            "minority_votes": self.minority_votes,
        }
