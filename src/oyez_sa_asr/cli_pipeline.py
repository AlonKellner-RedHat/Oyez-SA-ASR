# Generated by Claude
"""Pipeline command for running the full scrape-to-dataset workflow.

Supports dynamic option delegation with prefix-based forwarding:
- --{phase}-{option}: Applies to all commands in a phase
- --{phase}-{command}-{option}: Applies to specific command

Examples
--------
    oyez pipeline run --dataset-force
    oyez pipeline run --dataset-raw-force --dataset-raw-output-dir /custom
    oyez pipeline run --term 98-00,22
"""

import re
import subprocess
import sys
from typing import Annotated, Any

import typer
from rich.console import Console

from .term_parser import parse_term_list

pipeline_app = typer.Typer(
    help="Run the full pipeline from scraping to dataset creation"
)
console = Console(force_terminal=True)

# Define pipeline steps for each phase
SCRAPE_STEPS = [
    ("Scrape Index", "scrape", "index", False),
    ("Process Index", "process", "index", False),
    ("Scrape Cases", "scrape", "cases", True),
    ("Scrape Transcripts", "scrape", "transcripts", True),
    ("Scrape Audio", "scrape", "audio", True),
]

PROCESS_STEPS = [
    ("Process Cases", "process", "cases", True),
    ("Process Transcripts", "process", "transcripts", True),
    ("Process Audio", "process", "audio", True),
    ("Process Speakers", "process", "speakers", True),
]

DATASET_STEPS = [
    ("Dataset Raw", "dataset", "raw", True),
    ("Dataset Flex", "dataset", "flex", True),
    ("Dataset Simple", "dataset", "simple", False),
]

# Command mapping for option delegation
COMMAND_MAP: dict[str, dict[str, list[str]]] = {
    "scrape": {
        "index": ["scrape", "index"],
        "cases": ["scrape", "cases"],
        "transcripts": ["scrape", "transcripts"],
        "audio": ["scrape", "audio"],
    },
    "process": {
        "index": ["process", "index"],
        "cases": ["process", "cases"],
        "transcripts": ["process", "transcripts"],
        "audio": ["process", "audio"],
        "speakers": ["process", "speakers"],
    },
    "dataset": {
        "raw": ["dataset", "raw"],
        "flex": ["dataset", "flex"],
        "simple": ["dataset", "simple"],
    },
}


def parse_delegated_options(
    extra_args: list[str],
) -> dict[tuple[str, str | None], dict[str, Any]]:
    """Parse command-line args for delegated options.

    Edited by Claude: Dynamic option delegation parser.

    Args:
        extra_args: List of extra arguments from Typer context

    Returns
    -------
        Dict mapping (phase, command) to option dict.
        Structure: {("scrape", None): {"force": True}, ("dataset", "raw"): {"force": True, "output-dir": "/path"}}
    """
    delegated: dict[tuple[str, str | None], dict[str, Any]] = {}

    # Patterns for matching delegated options
    # Phase-level: --{phase}-{option}
    phase_pattern = re.compile(r"^--(scrape|process|dataset)-(.+)$")
    # Command-level: --{phase}-{command}-{option}
    command_pattern = re.compile(
        r"^--(scrape|process|dataset)-(index|cases|transcripts|audio|speakers|raw|flex|simple)-(.+)$"
    )

    i = 0
    while i < len(extra_args):
        arg = extra_args[i]

        # Try command-level pattern first (more specific)
        match = command_pattern.match(arg)
        if match:
            phase, command, option_name = match.groups()
            # Get the value (next arg if not a flag)
            if i + 1 < len(extra_args) and not extra_args[i + 1].startswith("--"):
                value = extra_args[i + 1]
                i += 2
            else:
                # Boolean flag
                value = True
                i += 1

            key = (phase, command)
            if key not in delegated:
                delegated[key] = {}
            delegated[key][option_name] = value
            continue

        # Try phase-level pattern
        match = phase_pattern.match(arg)
        if match:
            phase, option_name = match.groups()
            # Get the value (next arg if not a flag)
            if i + 1 < len(extra_args) and not extra_args[i + 1].startswith("--"):
                value = extra_args[i + 1]
                i += 2
            else:
                # Boolean flag
                value = True
                i += 1

            key = (phase, None)
            if key not in delegated:
                delegated[key] = {}
            delegated[key][option_name] = value
            continue

        i += 1

    return delegated


def build_command_args(
    phase: str,
    command: str,
    delegated_opts: dict[tuple[str, str | None], dict[str, Any]],
    global_terms: list[str] | None,
    use_terms: bool,
) -> list[str]:
    """Build command arguments with delegated options.

    Edited by Claude: Builds command args with option delegation support.

    Args:
        phase: Phase name (scrape, process, dataset)
        command: Command name (index, cases, etc.)
        delegated_opts: Dictionary of delegated options
        global_terms: Global term list
        use_terms: Whether this command uses terms

    Returns
    -------
        List of command arguments
    """
    args: list[str] = []

    # Get command-specific options (highest priority)
    cmd_key = (phase, command)
    cmd_opts = delegated_opts.get(cmd_key, {})

    # Get phase-level options (lower priority, but override global)
    phase_key = (phase, None)
    phase_opts = delegated_opts.get(phase_key, {})

    # Merge: command-specific overrides phase-level
    merged_opts = {**phase_opts, **cmd_opts}

    # Add terms if this command uses them
    if use_terms and global_terms:
        for term in global_terms:
            args.extend(["--term", term])

    # Add delegated options
    for opt_name, opt_value in merged_opts.items():
        if isinstance(opt_value, bool):
            if opt_value:
                args.append(f"--{opt_name}")
        elif opt_value is not None:
            # Special handling for term options - expand ranges/abbreviations
            if opt_name == "term":
                # opt_value might be a string (from delegated) or list
                if isinstance(opt_value, str):
                    expanded = parse_term_list([opt_value])
                    if expanded:
                        for term in expanded:
                            args.extend(["--term", term])
                elif isinstance(opt_value, list):
                    expanded = parse_term_list(opt_value)
                    if expanded:
                        for term in expanded:
                            args.extend(["--term", term])
                else:
                    # Fallback
                    args.extend([f"--{opt_name}", str(opt_value)])
            else:
                # Handle Path objects and other types
                args.extend([f"--{opt_name}", str(opt_value)])

    return args


def _run_step(step_name: str, cmd: list[str]) -> bool:
    """Run a pipeline step and return success status."""
    console.print(f"\n[bold blue]{'=' * 60}[/bold blue]")
    console.print(f"[bold]Step: {step_name}[/bold]")
    console.print(f"[dim]Command: {' '.join(cmd)}[/dim]")
    console.print(f"[bold blue]{'=' * 60}[/bold blue]\n")

    # S603: Safe - cmd is constructed from sys.executable and validated constants/terms
    result = subprocess.run(cmd, check=False)  # noqa: S603
    if result.returncode != 0:
        console.print(
            f"\n[red]Step '{step_name}' failed with exit code {result.returncode}[/red]"
        )
        return False
    console.print(f"\n[green]Step '{step_name}' completed successfully[/green]")
    return True


def _run_phase(
    phase_name: str,
    steps: list[tuple[str, str, str, bool]],
    base_cmd: list[str],
    delegated_opts: dict[tuple[str, str | None], dict[str, Any]],
    global_terms: list[str] | None,
) -> list[str]:
    """Run a phase of the pipeline and return list of failed step names.

    Edited by Claude: Updated to use dynamic option delegation.
    """
    console.print(f"\n[bold magenta]{phase_name}[/bold magenta]")
    failed = []
    for step_name, phase, command, use_terms in steps:
        cmd_parts = COMMAND_MAP[phase][command]
        cmd = [*base_cmd, *cmd_parts]

        # Build args with delegated options
        args = build_command_args(
            phase, command, delegated_opts, global_terms, use_terms
        )
        cmd.extend(args)

        if not _run_step(step_name, cmd):
            failed.append(step_name.lower())
    return failed


@pipeline_app.command(
    name="run",
    context_settings={"allow_extra_args": True, "ignore_unknown_options": True},
)
def pipeline_run(
    ctx: typer.Context,
    terms: Annotated[
        list[str] | None,
        typer.Option(
            "--term",
            "-T",
            help="Filter to specific term(s). Supports ranges (98-00), abbreviations (98), and comma-separated lists (98-00,22)",
        ),
    ] = None,
    skip_scrape: Annotated[
        bool,
        typer.Option("--skip-scrape", help="Skip scraping steps (use cached data)"),
    ] = False,
    skip_process: Annotated[
        bool,
        typer.Option("--skip-process", help="Skip processing steps"),
    ] = False,
    skip_dataset: Annotated[
        bool,
        typer.Option("--skip-dataset", help="Skip dataset creation steps"),
    ] = False,
) -> None:
    """Run the full pipeline from scraping to dataset creation.

    This command runs all steps in order:
    1. Scrape: index, cases, transcripts, audio
    2. Process: index, cases, transcripts, audio, speakers
    3. Dataset: raw, flex, simple

    Enhanced term parsing supports:
    - Full years: 1998, 2022
    - Abbreviations: 98 → 1998, 22 → 2022
    - Ranges: 98-00 → 1998-2000, 2020-22 → 2020-2022
    - Comma-separated: 98-00,22 → 1998-2000, 2022

    Dynamic option delegation:
    - --{phase}-{option}: Applies to all commands in phase (e.g., --dataset-force)
    - --{phase}-{command}-{option}: Applies to specific command (e.g., --dataset-raw-force)

    Examples
    --------
        oyez pipeline run --term 98-00,22
        oyez pipeline run --dataset-force
        oyez pipeline run --dataset-raw-force --dataset-raw-output-dir /custom
        oyez pipeline run --process-audio-force --scrape-force
    """
    # Parse delegated options from extra args
    # Edited by Claude: Dynamic option delegation
    delegated_opts = parse_delegated_options(ctx.args if ctx.args else [])

    # Parse and expand terms
    # Edited by Claude: Enhanced term parsing
    expanded_terms = parse_term_list(terms)

    console.print("[bold cyan]Starting Oyez SA-ASR Pipeline[/bold cyan]")
    if expanded_terms:
        console.print(f"Terms: {', '.join(expanded_terms)}")
    else:
        console.print("Terms: all available")

    # Show delegated options if any
    if delegated_opts:
        console.print("\n[dim]Delegated options:[/dim]")
        # Edited by Claude: Fix sorting with None values - use empty string for None
        for (phase, command), opts in sorted(
            delegated_opts.items(), key=lambda x: (x[0][0], x[0][1] or "")
        ):
            cmd_desc = f"{phase}-{command}" if command else phase
            opt_str = ", ".join(f"{k}={v}" for k, v in opts.items())
            console.print(f"  [dim]{cmd_desc}:[/dim] {opt_str}")

    console.print()

    base_cmd = [sys.executable, "-m", "oyez_sa_asr"]
    failed_steps: list[str] = []

    if not skip_scrape:
        failed_steps.extend(
            _run_phase(
                "Phase 1: Scraping",
                SCRAPE_STEPS,
                base_cmd,
                delegated_opts,
                expanded_terms,
            )
        )

    if not skip_process:
        failed_steps.extend(
            _run_phase(
                "Phase 2: Processing",
                PROCESS_STEPS,
                base_cmd,
                delegated_opts,
                expanded_terms,
            )
        )

    if not skip_dataset:
        failed_steps.extend(
            _run_phase(
                "Phase 3: Dataset Creation",
                DATASET_STEPS,
                base_cmd,
                delegated_opts,
                expanded_terms,
            )
        )

    # Summary
    console.print("\n" + "=" * 60)
    console.print("[bold]Pipeline Summary[/bold]")
    console.print("=" * 60)

    if failed_steps:
        console.print(f"\n[red]Failed steps ({len(failed_steps)}):[/red]")
        for step in failed_steps:
            console.print(f"  - {step}")
        console.print("\n[yellow]Pipeline completed with errors.[/yellow]")
        raise typer.Exit(1)

    console.print("\n[bold green]Pipeline completed successfully![/bold green]")
    console.print("\nNext steps:")
    console.print("  - View stats: oyez stats audio")
    console.print("  - Explore datasets: python examples/demo_simple_dataset.py")


def register_pipeline_command(app: typer.Typer) -> None:
    """Register the pipeline command with the main app."""
    app.add_typer(pipeline_app, name="pipeline")
