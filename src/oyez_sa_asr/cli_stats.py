# Generated by Claude
"""Stats commands for displaying aggregate statistics."""

import json
from collections import Counter
from dataclasses import dataclass, field
from pathlib import Path
from typing import Annotated

import typer
from rich.console import Console

from .cli_dataset_helpers import collect_recordings
from .cli_stats_cases import register_cases_command
from .term_filter import filter_dirs

stats_app = typer.Typer(help="Display statistics for processed data")
console = Console(force_terminal=True)

# Register the cases command
register_cases_command(stats_app)


def _format_size(size_bytes: int) -> str:
    """Format bytes as human-readable size."""
    for unit in ("B", "KB", "MB", "GB", "TB"):
        if abs(size_bytes) < 1024:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024  # type: ignore[assignment]
    return f"{size_bytes:.1f} PB"


def _format_hours(seconds: float) -> str:
    """Format seconds as hours with one decimal."""
    hours = seconds / 3600
    return f"{hours:,.1f}"


@stats_app.command(name="audio")
def stats_audio(
    data_dir: Annotated[
        Path,
        typer.Option("--data-dir", "-d", help="Processed data directory"),
    ] = Path("data"),
    terms: Annotated[
        list[str] | None,
        typer.Option("--term", "-T", help="Filter to specific term(s)"),
    ] = None,
) -> None:
    """Display audio recording statistics."""
    audio_dir = data_dir / "audio"

    if not audio_dir.exists():
        console.print(f"[red]Error:[/red] {audio_dir} not found.")
        console.print("Run 'oyez process audio' first.")
        raise typer.Exit(1)

    recordings = collect_recordings(audio_dir, terms)

    if not recordings:
        console.print("[yellow]No recordings found.[/yellow]")
        return

    # Calculate totals
    total_duration = sum(float(r.get("duration_sec") or 0) for r in recordings)
    total_size = 0

    # Count files by getting actual file sizes
    for r in recordings:
        audio_path_str = r.get("audio_path")
        if audio_path_str and isinstance(audio_path_str, str):
            audio_path = audio_dir / audio_path_str
            if audio_path.exists():
                total_size += audio_path.stat().st_size

    # Count by era, format, and term
    era_counts: Counter[str] = Counter()
    format_counts: Counter[str] = Counter()
    term_counts: Counter[str] = Counter()
    for r in recordings:
        era_counts[str(r.get("source_era") or "unknown")] += 1
        format_counts[str(r.get("source_format") or "unknown")] += 1
        term_counts[str(r.get("term") or "unknown")] += 1

    # Output
    console.print()
    console.print("[bold]Audio Statistics[/bold]")
    console.print("=" * 40)
    console.print(f"Total recordings: {len(recordings):,}")
    console.print(f"Total duration: {_format_hours(total_duration)} hours")
    console.print(f"Total size: {_format_size(total_size)}")
    console.print()

    console.print("[bold]By era:[/bold]")
    for era, count in era_counts.most_common():
        pct = count / len(recordings) * 100
        console.print(f"  {era}: {count:,} files ({pct:.1f}%)")
    console.print()

    console.print("[bold]By source format:[/bold]")
    for fmt, count in format_counts.most_common():
        console.print(f"  {fmt}: {count:,} files")
    console.print()

    console.print("[bold]By term (top 5):[/bold]")
    for term, count in term_counts.most_common(5):
        console.print(f"  {term}: {count:,} files")


@dataclass
class TranscriptStats:
    """Accumulated transcript statistics."""

    total_transcripts: int = 0
    total_turns: int = 0
    total_valid_turns: int = 0
    total_spoken_seconds: float = 0.0
    total_words: int = 0
    speaker_counts: Counter[str] = field(default_factory=Counter)
    type_counts: Counter[str] = field(default_factory=Counter)


def _collect_transcript_stats(
    transcripts_dir: Path, terms: list[str] | None
) -> TranscriptStats:
    """Collect statistics from processed transcripts."""
    stats = TranscriptStats()
    term_dirs = filter_dirs(list(transcripts_dir.iterdir()), terms)

    for term_dir in term_dirs:
        if not term_dir.is_dir():
            continue
        for docket_dir in term_dir.iterdir():
            if not docket_dir.is_dir():
                continue
            for transcript_file in docket_dir.glob("*.json"):
                _process_transcript_file(transcript_file, stats)

    return stats


def _process_transcript_file(transcript_file: Path, stats: TranscriptStats) -> None:
    """Process a single transcript file and update stats."""
    try:
        with transcript_file.open() as f:
            data = json.load(f)

        stats.total_transcripts += 1
        transcript_type = data.get("type", "unknown")
        stats.type_counts[transcript_type] += 1

        for turn in data.get("turns", []):
            stats.total_turns += 1
            if turn.get("is_valid"):
                stats.total_valid_turns += 1
                stats.total_spoken_seconds += turn.get("duration", 0) or 0
                stats.total_words += turn.get("word_count", 0) or 0
                speaker = turn.get("speaker_name")
                if speaker:
                    stats.speaker_counts[speaker] += 1

    except (json.JSONDecodeError, KeyError):
        pass


@stats_app.command(name="transcripts")
def stats_transcripts(
    data_dir: Annotated[
        Path,
        typer.Option("--data-dir", "-d", help="Processed data directory"),
    ] = Path("data"),
    terms: Annotated[
        list[str] | None,
        typer.Option("--term", "-T", help="Filter to specific term(s)"),
    ] = None,
) -> None:
    """Display transcript statistics."""
    transcripts_dir = data_dir / "transcripts"

    if not transcripts_dir.exists():
        console.print(f"[red]Error:[/red] {transcripts_dir} not found.")
        console.print("Run 'oyez process transcripts' first.")
        raise typer.Exit(1)

    stats = _collect_transcript_stats(transcripts_dir, terms)

    if stats.total_transcripts == 0:
        console.print("[yellow]No transcripts found.[/yellow]")
        return

    valid_pct = (
        stats.total_valid_turns / stats.total_turns * 100
        if stats.total_turns > 0
        else 0
    )

    # Output
    console.print()
    console.print("[bold]Transcript Statistics[/bold]")
    console.print("=" * 40)
    console.print(f"Total transcripts: {stats.total_transcripts:,}")
    console.print(f"Total turns: {stats.total_turns:,}")
    console.print(f"Total valid turns: {stats.total_valid_turns:,} ({valid_pct:.1f}%)")
    console.print(
        f"Total spoken time: {_format_hours(stats.total_spoken_seconds)} hours"
    )
    console.print(f"Total words: {stats.total_words:,}")
    console.print()

    console.print("[bold]Top speakers:[/bold]")
    for i, (speaker, count) in enumerate(stats.speaker_counts.most_common(10), 1):
        console.print(f"  {i}. {speaker} - {count:,} turns")
    console.print()

    console.print("[bold]By type:[/bold]")
    for transcript_type, count in stats.type_counts.most_common():
        console.print(f"  {transcript_type}: {count:,}")
