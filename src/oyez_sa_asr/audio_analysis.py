# Generated by Claude
"""Audio analysis utilities for anomaly detection.

Implements Short-Term Energy (STE) variance analysis, a well-established
Voice Activity Detection (VAD) technique (also known as Long-Term Signal
Variability / LTSV in literature).

Key insight: Speech has high energy variation (bursts, pauses, emphasis),
while corrupted noise has constant energy levels.
"""

from typing import Any

import numpy as np
from numpy.typing import NDArray

# Thresholds based on VAD literature
_SILENCE_RMS_THRESHOLD = 1e-6  # Below this = all-zeros/silent
_LOW_CV_THRESHOLD = 0.25  # Below this = constant noise (no speech)
_FRAME_MS = 25  # Standard VAD frame size (20-50ms per literature)


def compute_frame_energies(
    samples: NDArray[np.floating[Any]],
    sample_rate: int,
    frame_ms: int = _FRAME_MS,
) -> NDArray[np.float64]:
    """Compute RMS energy per frame.

    Args:
        samples: Audio samples, shape (channels, num_samples) or (num_samples,).
        sample_rate: Sample rate in Hz.
        frame_ms: Frame length in milliseconds (default 25ms per VAD standards).

    Returns
    -------
        Array of RMS energy values, one per frame.
    """
    # Convert to mono if stereo
    if samples.ndim == 2:
        samples = samples.mean(axis=0)

    frame_size = int(sample_rate * frame_ms / 1000)
    frame_size = max(frame_size, 1)

    num_samples = len(samples)
    if num_samples < frame_size:
        # Audio too short - treat as single frame
        return np.array([np.sqrt(np.mean(samples**2))], dtype=np.float64)

    # Number of complete frames
    num_frames = num_samples // frame_size

    # Reshape into frames and compute RMS per frame
    trimmed = samples[: num_frames * frame_size]
    frames = trimmed.reshape(num_frames, frame_size)
    rms_values = np.sqrt(np.mean(frames**2, axis=1))

    return rms_values.astype(np.float64)


def compute_energy_cv(frame_energies: NDArray[np.float64]) -> float:
    """Compute coefficient of variation of frame energies.

    CV = std(energies) / mean(energies)

    - High CV (>0.5): Speech with natural variation
    - Low CV (<0.25): Constant noise without speech

    Args:
        frame_energies: Array of RMS energy values per frame.

    Returns
    -------
        Coefficient of variation (0.0 if mean is zero).
    """
    if len(frame_energies) == 0:
        return 0.0

    mean_energy = float(np.mean(frame_energies))
    if mean_energy < _SILENCE_RMS_THRESHOLD:
        return 0.0

    std_energy = float(np.std(frame_energies))
    return std_energy / mean_energy


def detect_anomalies(
    samples: NDArray[np.floating[Any]],
    sample_rate: int,
) -> dict[str, float | bool | str | None]:
    """Detect audio anomalies using energy-based analysis.

    Uses Short-Term Energy (STE) variance (a standard VAD technique) to
    distinguish speech from corrupted/noisy audio.

    Args:
        samples: Audio samples, shape (channels, num_samples) or (num_samples,).
        sample_rate: Sample rate in Hz.

    Returns
    -------
        Dict with:
        - energy_cv: Coefficient of variation of frame energies
        - mean_rms: Average RMS loudness
        - is_silent: True if audio is all zeros or near-zero
        - is_anomaly: True if silent or constant noise detected
        - anomaly_reason: "silent", "constant_noise", or None (valid)
    """
    # Convert to mono for analysis
    mono = samples.mean(axis=0) if samples.ndim == 2 else samples

    # Compute overall RMS
    mean_rms = float(np.sqrt(np.mean(mono**2)))

    # Check for silence/all-zeros
    if mean_rms < _SILENCE_RMS_THRESHOLD:
        return {
            "energy_cv": 0.0,
            "mean_rms": mean_rms,
            "is_silent": True,
            "is_anomaly": True,
            "anomaly_reason": "silent",
        }

    # Compute frame energies and CV
    frame_energies = compute_frame_energies(samples, sample_rate)
    energy_cv = compute_energy_cv(frame_energies)

    # Check for constant noise (low energy variation)
    if energy_cv < _LOW_CV_THRESHOLD:
        return {
            "energy_cv": energy_cv,
            "mean_rms": mean_rms,
            "is_silent": False,
            "is_anomaly": True,
            "anomaly_reason": "constant_noise",
        }

    # Valid speech
    return {
        "energy_cv": energy_cv,
        "mean_rms": mean_rms,
        "is_silent": False,
        "is_anomaly": False,
        "anomaly_reason": None,
    }
