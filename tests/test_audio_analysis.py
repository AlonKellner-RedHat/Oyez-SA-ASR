# Generated by Claude
"""Tests for audio_analysis module."""

import numpy as np

from oyez_sa_asr.audio_analysis import (
    compute_energy_cv,
    compute_frame_energies,
    detect_anomalies,
)

SAMPLE_RATE = 16000


class TestComputeFrameEnergies:
    """Tests for compute_frame_energies function."""

    def test_constant_amplitude_uniform_energy(self) -> None:
        """Constant amplitude should produce uniform frame energies."""
        # 1 second of constant amplitude
        samples = np.full(SAMPLE_RATE, 0.5, dtype=np.float32)
        energies = compute_frame_energies(samples, SAMPLE_RATE)

        # All frames should have similar energy
        assert len(energies) > 0
        assert np.std(energies) < 0.01  # Very low variation

    def test_varying_amplitude_varied_energy(self) -> None:
        """Varying amplitude should produce varied frame energies."""
        # Create audio with alternating loud and quiet sections
        samples = np.zeros(SAMPLE_RATE, dtype=np.float32)
        # First half loud, second half quiet
        samples[: SAMPLE_RATE // 2] = 0.8
        samples[SAMPLE_RATE // 2 :] = 0.1

        energies = compute_frame_energies(samples, SAMPLE_RATE)

        # Should have significant variation
        assert len(energies) > 0
        assert np.std(energies) > 0.1

    def test_short_audio_handled(self) -> None:
        """Very short audio should be handled gracefully."""
        # Less than one frame (25ms = 400 samples at 16kHz)
        samples = np.full(100, 0.5, dtype=np.float32)
        energies = compute_frame_energies(samples, SAMPLE_RATE)

        # Should return at least one energy value
        assert len(energies) >= 1


class TestComputeEnergyCv:
    """Tests for compute_energy_cv function."""

    def test_uniform_energies_low_cv(self) -> None:
        """Uniform energies should produce low CV."""
        energies = np.full(100, 0.5, dtype=np.float64)
        cv = compute_energy_cv(energies)
        assert cv < 0.01  # Nearly zero variation

    def test_varied_energies_high_cv(self) -> None:
        """Varied energies should produce high CV."""
        # Alternating high and low values
        energies = np.array([0.1, 0.9] * 50, dtype=np.float64)
        cv = compute_energy_cv(energies)
        assert cv > 0.5  # High variation

    def test_empty_array_returns_zero(self) -> None:
        """Empty array should return 0."""
        energies = np.array([], dtype=np.float64)
        cv = compute_energy_cv(energies)
        assert cv == 0.0

    def test_near_zero_energies_returns_zero(self) -> None:
        """Near-zero energies should return 0 (avoid division issues)."""
        energies = np.full(100, 1e-10, dtype=np.float64)
        cv = compute_energy_cv(energies)
        assert cv == 0.0


class TestDetectAnomalies:
    """Tests for detect_anomalies function."""

    def test_all_zeros_detected(self) -> None:
        """All-zeros array should be marked as silent anomaly."""
        samples = np.zeros((1, SAMPLE_RATE), dtype=np.float32)
        result = detect_anomalies(samples, SAMPLE_RATE)

        assert result["is_silent"] is True
        assert result["is_anomaly"] is True
        assert result["anomaly_reason"] == "silent"
        assert isinstance(result["mean_rms"], float) and result["mean_rms"] < 1e-6

    def test_constant_noise_detected(self) -> None:
        """Constant amplitude noise should be marked as anomaly."""
        # Constant noise at moderate amplitude
        samples = np.full((1, SAMPLE_RATE * 2), 0.3, dtype=np.float32)
        result = detect_anomalies(samples, SAMPLE_RATE)

        assert result["is_silent"] is False
        assert result["is_anomaly"] is True
        assert result["anomaly_reason"] == "constant_noise"
        assert isinstance(result["energy_cv"], float) and result["energy_cv"] < 0.25

    def test_varying_amplitude_valid(self) -> None:
        """Speech-like varying amplitude should be marked as valid."""
        # Simulate speech: alternating loud bursts and quiet pauses
        samples = np.zeros((1, SAMPLE_RATE * 2), dtype=np.float32)
        # Create 10 "bursts" with quiet gaps
        burst_len = SAMPLE_RATE // 5
        for i in range(10):
            start = i * burst_len * 2
            end = start + burst_len
            if end <= samples.shape[1]:
                samples[0, start:end] = np.random.uniform(0.3, 0.8, burst_len)

        result = detect_anomalies(samples, SAMPLE_RATE)

        assert result["is_silent"] is False
        assert result["is_anomaly"] is False
        assert result["anomaly_reason"] is None
        assert isinstance(result["energy_cv"], float) and result["energy_cv"] >= 0.25

    def test_short_audio_handled(self) -> None:
        """Very short audio (<100ms) should be handled gracefully."""
        # 50ms of audio
        num_samples = SAMPLE_RATE // 20
        samples = np.random.uniform(-0.5, 0.5, (1, num_samples)).astype(np.float32)
        result = detect_anomalies(samples, SAMPLE_RATE)

        # Should return valid structure without error
        assert "is_anomaly" in result
        assert "energy_cv" in result
        assert "mean_rms" in result

    def test_mono_input(self) -> None:
        """Should work with mono (1D) input."""
        samples = np.zeros(SAMPLE_RATE, dtype=np.float32)
        result = detect_anomalies(samples, SAMPLE_RATE)

        assert result["is_silent"] is True
        assert result["is_anomaly"] is True

    def test_stereo_input(self) -> None:
        """Should work with stereo (2D with 2 channels) input."""
        # Stereo with varying content
        samples = np.zeros((2, SAMPLE_RATE * 2), dtype=np.float32)
        burst_len = SAMPLE_RATE // 5
        for i in range(10):
            start = i * burst_len * 2
            end = start + burst_len
            if end <= samples.shape[1]:
                samples[:, start:end] = np.random.uniform(0.3, 0.8, (2, burst_len))

        result = detect_anomalies(samples, SAMPLE_RATE)

        assert result["is_silent"] is False
        # Stereo is averaged to mono, should still detect variation
        assert "energy_cv" in result


class TestEdgeCases:
    """Edge case tests."""

    def test_single_sample(self) -> None:
        """Single sample should not crash."""
        samples = np.array([0.5], dtype=np.float32)
        result = detect_anomalies(samples, SAMPLE_RATE)
        assert "is_anomaly" in result

    def test_very_long_audio(self) -> None:
        """Very long audio (1 hour) should work efficiently."""
        # 1 hour at 16kHz = 57.6M samples - use smaller for test
        # Just test 10 seconds to verify it works
        samples = np.random.uniform(-0.3, 0.3, (1, SAMPLE_RATE * 10)).astype(np.float32)
        # Add some bursts for variation
        for i in range(5):
            start = i * SAMPLE_RATE * 2
            samples[0, start : start + SAMPLE_RATE // 2] *= 3

        result = detect_anomalies(samples, SAMPLE_RATE)
        assert "is_anomaly" in result
