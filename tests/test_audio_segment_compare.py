# Generated by Claude
"""Tests comparing streaming vs full-load segment extraction."""

import tempfile
from pathlib import Path

import numpy as np

from oyez_sa_asr.audio_segment import extract_segments_batch
from oyez_sa_asr.audio_utils import load_audio, save_audio


def _create_test_audio(duration_sec: float, sample_rate: int = 16000) -> Path:
    """Create a test FLAC audio file with known content."""
    with tempfile.NamedTemporaryFile(suffix=".flac", delete=False) as tmpfile:
        path = Path(tmpfile.name)

    t = np.linspace(0, duration_sec, int(duration_sec * sample_rate), dtype=np.float32)
    samples = np.sin(2 * np.pi * 440 * t) * 0.5
    samples = samples[np.newaxis, :]

    save_audio(samples, sample_rate, path, format="flac", bits_per_sample=16)
    return path


class TestStreamingVsFullLoad:
    """Critical tests ensuring streaming and full-load produce identical results."""

    def test_exact_sample_values_match(self) -> None:
        """Verify streaming and full-load produce identical sample values.

        This is the most critical test - both extraction methods must produce
        byte-for-byte identical audio samples.
        """
        # Use shorter duration to speed up test
        path = _create_test_audio(5.0)
        try:
            segments = [(0.0, 1.0), (1.5, 2.5), (2.0, 3.0), (4.0, 5.0)]

            streaming_result = extract_segments_batch(
                path, segments, use_streaming=True
            )
            full_load_result = extract_segments_batch(
                path, segments, use_streaming=False
            )

            assert len(streaming_result) == len(full_load_result)

            for i, (streaming_bytes, full_bytes) in enumerate(
                zip(streaming_result, full_load_result, strict=True)
            ):
                assert streaming_bytes[:4] == b"fLaC"
                assert full_bytes[:4] == b"fLaC"

                with tempfile.NamedTemporaryFile(suffix=".flac", delete=False) as f:
                    f.write(streaming_bytes)
                    streaming_path = Path(f.name)
                with tempfile.NamedTemporaryFile(suffix=".flac", delete=False) as f:
                    f.write(full_bytes)
                    full_path = Path(f.name)

                streaming_audio, streaming_sr = load_audio(streaming_path)
                full_audio, full_sr = load_audio(full_path)

                assert streaming_sr == full_sr
                assert streaming_audio.shape == full_audio.shape, (
                    f"Segment {i}: shape mismatch {streaming_audio.shape} vs {full_audio.shape}"
                )

                mse = float(np.mean((streaming_audio - full_audio) ** 2))
                assert mse == 0.0, f"Segment {i}: MSE={mse}, expected 0.0"

                streaming_path.unlink()
                full_path.unlink()
        finally:
            path.unlink()

    def test_fractional_times_match(self) -> None:
        """Verify fractional time boundaries produce identical results."""
        # Use shorter duration to speed up test
        path = _create_test_audio(5.0)
        try:
            # Adjust segments to fit within 5.0 second duration
            segments = [(1.333, 2.777), (2.8, 3.5), (4.0, 4.9)]

            streaming_result = extract_segments_batch(
                path, segments, use_streaming=True
            )
            full_load_result = extract_segments_batch(
                path, segments, use_streaming=False
            )

            for i, (s_bytes, f_bytes) in enumerate(
                zip(streaming_result, full_load_result, strict=True)
            ):
                with tempfile.NamedTemporaryFile(suffix=".flac", delete=False) as f:
                    f.write(s_bytes)
                    s_path = Path(f.name)
                with tempfile.NamedTemporaryFile(suffix=".flac", delete=False) as f:
                    f.write(f_bytes)
                    f_path = Path(f.name)

                s_audio, _ = load_audio(s_path)
                f_audio, _ = load_audio(f_path)

                assert s_audio.shape == f_audio.shape
                mse = float(np.mean((s_audio - f_audio) ** 2))
                assert mse == 0.0, f"Segment {i}: fractional times MSE={mse}"

                s_path.unlink()
                f_path.unlink()
        finally:
            path.unlink()
