# Generated by Claude
"""Unit tests for OyezCasesTraverser."""

import tempfile
from pathlib import Path
from unittest.mock import patch

import pytest

from oyez_sa_asr.scraper import AdaptiveFetcher, OyezCasesTraverser, RequestMetadata
from oyez_sa_asr.scraper.models import FetchResult


class TestOyezCasesTraverser:
    """Tests for OyezCasesTraverser."""

    def test_build_url(self) -> None:
        """Should build correct API URL."""
        with tempfile.TemporaryDirectory() as tmpdir:
            fetcher = AdaptiveFetcher.create(Path(tmpdir))
            traverser = OyezCasesTraverser(fetcher, per_page=100)
            url = traverser._build_url(0)
            assert "page=0" in url
            assert "per_page=100" in url
            assert "labels=true" in url
            url = traverser._build_url(5)
            assert "page=5" in url

    def test_is_empty_result(self) -> None:
        """Should correctly identify empty results."""
        assert OyezCasesTraverser._is_empty_result(None) is True
        assert OyezCasesTraverser._is_empty_result([]) is True
        assert OyezCasesTraverser._is_empty_result([{"id": 1}]) is False

    @pytest.mark.asyncio
    async def test_traverse_stops_on_empty(self) -> None:
        """Should stop traversing when empty results received."""
        with tempfile.TemporaryDirectory() as tmpdir:
            fetcher = AdaptiveFetcher.create(Path(tmpdir))
            traverser = OyezCasesTraverser(fetcher, per_page=10)
            responses = [[{"id": 1}, {"id": 2}], []]
            call_count = 0

            async def mock_fetch_one(
                request: RequestMetadata, **_: bool
            ) -> FetchResult:
                nonlocal call_count
                data = responses[call_count] if call_count < len(responses) else []
                call_count += 1
                return FetchResult(
                    url=request.url, success=True, status_code=200, data=data
                )

            with patch.object(fetcher, "fetch_one", side_effect=mock_fetch_one):
                pages = [page async for page, result in traverser.traverse()]
            assert pages == [0, 1]

    @pytest.mark.asyncio
    async def test_traverse_respects_max_pages(self) -> None:
        """Should stop at max_pages limit."""
        with tempfile.TemporaryDirectory() as tmpdir:
            fetcher = AdaptiveFetcher.create(Path(tmpdir))
            traverser = OyezCasesTraverser(fetcher, per_page=10, max_pages=2)

            async def mock_fetch_one(
                request: RequestMetadata, **_: bool
            ) -> FetchResult:
                return FetchResult(
                    url=request.url, success=True, status_code=200, data=[{"id": 1}]
                )

            with patch.object(fetcher, "fetch_one", side_effect=mock_fetch_one):
                pages = [page async for page, result in traverser.traverse()]
            assert pages == [0, 1]

    @pytest.mark.asyncio
    async def test_traverse_stops_on_error(self) -> None:
        """Should stop traversing on fetch error."""
        with tempfile.TemporaryDirectory() as tmpdir:
            fetcher = AdaptiveFetcher.create(Path(tmpdir))
            traverser = OyezCasesTraverser(fetcher, per_page=10)

            async def mock_fetch_one(
                request: RequestMetadata, **_: bool
            ) -> FetchResult:
                return FetchResult(url=request.url, success=False, error="Net error")

            with patch.object(fetcher, "fetch_one", side_effect=mock_fetch_one):
                pages = [page async for page, result in traverser.traverse()]
            assert pages == [0]

    @pytest.mark.asyncio
    async def test_fetch_all_combines_results(self) -> None:
        """Should combine results from all pages."""
        with tempfile.TemporaryDirectory() as tmpdir:
            fetcher = AdaptiveFetcher.create(Path(tmpdir))
            traverser = OyezCasesTraverser(fetcher, per_page=2, max_pages=2)
            responses = [[{"id": 1}, {"id": 2}], [{"id": 3}]]
            call_count = 0

            async def mock_fetch_one(
                request: RequestMetadata, **_: bool
            ) -> FetchResult:
                nonlocal call_count
                data = responses[call_count] if call_count < len(responses) else []
                call_count += 1
                return FetchResult(
                    url=request.url, success=True, status_code=200, data=data
                )

            with patch.object(fetcher, "fetch_one", side_effect=mock_fetch_one):
                cases = await traverser.fetch_all()
            assert len(cases) == 3
            assert cases[0]["id"] == 1
            assert cases[2]["id"] == 3

    @pytest.mark.asyncio
    async def test_fetch_all_handles_errors(self) -> None:
        """Should handle fetch errors in fetch_all (lines 98-99)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            fetcher = AdaptiveFetcher.create(Path(tmpdir))
            traverser = OyezCasesTraverser(fetcher, per_page=10)

            async def mock_fetch_one(
                request: RequestMetadata, **_: bool
            ) -> FetchResult:
                # First page succeeds, second fails
                if "page=0" in request.url:
                    return FetchResult(
                        url=request.url, success=True, status_code=200, data=[{"id": 1}]
                    )
                return FetchResult(
                    url=request.url, success=False, error="Network error"
                )

            with patch.object(fetcher, "fetch_one", side_effect=mock_fetch_one):
                cases = await traverser.fetch_all()
            # Should return cases from successful page, handle error gracefully
            assert len(cases) == 1
