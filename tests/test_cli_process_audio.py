# Generated by Claude
"""TDD tests for process audio subcommand - basic execution tests."""

import importlib
import json
import math
import re
import tempfile
from concurrent.futures import BrokenExecutor
from pathlib import Path
from unittest.mock import MagicMock, patch

import numpy as np
from typer.testing import CliRunner

from oyez_sa_asr import cli_process_audio
from oyez_sa_asr.audio_source import AudioSource
from oyez_sa_asr.audio_utils import save_audio
from oyez_sa_asr.cli import app
from oyez_sa_asr.cli_process_audio import (
    _count_anomalies,
    _filter_pending_sources,
    _process_recording,
    _run_parallel_sources,
    _try_process_file,
    _validate_flac_files,
)

runner = CliRunner()


def strip_ansi(text: str) -> str:
    """Remove ANSI escape codes from text."""
    return re.sub(r"\x1b\[[0-9;]*m", "", text)


def make_sine(sr: int = 16000, dur: float = 0.5) -> np.ndarray:
    """Generate a sine wave."""
    t = np.linspace(0, dur, int(sr * dur), dtype=np.float32)
    return np.sin(2 * math.pi * 440 * t)


class TestProcessAudioHelp:
    """Test process audio help."""

    def test_help(self) -> None:
        """Should show help for process audio."""
        result = runner.invoke(app, ["process", "audio", "--help"])
        assert result.exit_code == 0
        output = strip_ansi(result.output)
        assert "--cache-dir" in output
        assert "--output-dir" in output


class TestProcessAudioExecution:
    """Test process audio command execution."""

    def test_empty_cache(self) -> None:
        """Should handle empty cache gracefully."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            result = runner.invoke(
                app,
                ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
            )
            assert result.exit_code == 0
            output = strip_ansi(result.output)
            assert "0" in output or "No" in output

    def test_processes_mp3_to_flac(self) -> None:
        """Should convert MP3 to FLAC and save metadata."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            mp3_dir = (
                cache_dir / "oyez.case-media.mp3" / "case_data" / "2020" / "19-123"
            )
            mp3_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.3)
            mp3_path = mp3_dir / "19-123_20201001-argument.mp3"
            save_audio(samples, 44100, mp3_path)

            result = runner.invoke(
                app,
                ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
            )
            assert result.exit_code == 0

            flac_path = output_dir / "2020" / "19-123" / "19-123_20201001-argument.flac"
            meta_path = (
                output_dir
                / "2020"
                / "19-123"
                / "19-123_20201001-argument.metadata.json"
            )
            assert flac_path.exists(), f"FLAC not found: {flac_path}"
            assert meta_path.exists(), f"Metadata not found: {meta_path}"

            with meta_path.open() as f:
                meta = json.load(f)
            assert meta["format"] == "mp3"
            assert meta["sample_rate"] == 44100
            assert "source_path" in meta

    def test_processes_ogg_to_flac(self) -> None:
        """Should convert OGG to FLAC."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            ogg_dir = (
                cache_dir / "oyez.case-media.ogg" / "case_data" / "2021" / "20-456"
            )
            ogg_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.2)
            ogg_path = ogg_dir / "20-456_20210501-opinion.ogg"
            save_audio(samples, 44100, ogg_path)

            result = runner.invoke(
                app,
                ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
            )
            assert result.exit_code == 0

            flac_path = output_dir / "2021" / "20-456" / "20-456_20210501-opinion.flac"
            assert flac_path.exists()

    def test_skips_already_processed(self) -> None:
        """Should skip files that already have output FLAC."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            mp3_dir = (
                cache_dir / "oyez.case-media.mp3" / "case_data" / "2020" / "19-999"
            )
            mp3_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.2)
            save_audio(samples, 44100, mp3_dir / "test_skip.mp3")

            out_flac_dir = output_dir / "2020" / "19-999"
            out_flac_dir.mkdir(parents=True)
            flac_path = out_flac_dir / "test_skip.flac"
            flac_path.write_bytes(b"dummy_existing_content")
            orig_mtime = flac_path.stat().st_mtime

            result = runner.invoke(
                app,
                ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
            )
            assert result.exit_code == 0
            output = strip_ansi(result.output)
            assert "skip" in output.lower()
            assert flac_path.stat().st_mtime == orig_mtime

    def test_workers_option_in_help(self) -> None:
        """Should show --workers option in help."""
        result = runner.invoke(app, ["process", "audio", "--help"])
        assert result.exit_code == 0
        output = strip_ansi(result.output)
        assert "--workers" in output or "-w" in output


class TestFlacValidation:
    """Test FLAC validation after processing."""

    def test_reports_missing_flac_files(self) -> None:
        """Should report when FLAC files are missing after processing."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"

            # Create sources that should have FLAC files but don't
            sources = [
                AudioSource("rec1", "2020", "19-999"),
                AudioSource("rec2", "2020", "19-888"),
            ]

            # Create output directories but no FLAC files
            for source in sources:
                out_dir = output_dir / source.term / source.docket
                out_dir.mkdir(parents=True)
                # Create metadata but not FLAC (simulating failed conversion)
                meta_path = out_dir / f"{source.recording_id}.metadata.json"
                meta_path.write_text('{"format": "mp3", "sample_rate": 44100}')

            # Validate - should find 2 missing FLACs
            missing_count, missing_sources = _validate_flac_files(sources, output_dir)
            assert missing_count == 2
            assert len(missing_sources) == 2
            assert missing_sources[0].recording_id == "rec1"
            assert missing_sources[1].recording_id == "rec2"

    def test_no_warning_when_all_flacs_exist(self) -> None:
        """Should not report warning when all FLACs are created successfully."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"

            # Create sources with FLAC files
            sources = [
                AudioSource("rec1", "2020", "19-888"),
            ]

            # Create output directory and FLAC file
            out_dir = output_dir / "2020" / "19-888"
            out_dir.mkdir(parents=True)
            flac_path = out_dir / "rec1.flac"
            # Create a minimal FLAC file (just write some bytes)
            flac_path.write_bytes(b"fLaC\x00\x00\x00")

            # Validate - should find 0 missing FLACs
            missing_count, missing_sources = _validate_flac_files(sources, output_dir)
            assert missing_count == 0
            assert len(missing_sources) == 0

    def test_reports_multiple_missing_files(self) -> None:
        """Should report count when multiple FLACs are missing."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"

            # Create 3 sources without FLAC files
            sources = [AudioSource(f"audio_{i}", "2020", f"case-{i}") for i in range(3)]

            # Create metadata but not FLAC for each
            for source in sources:
                out_dir = output_dir / source.term / source.docket
                out_dir.mkdir(parents=True)
                meta_path = out_dir / f"{source.recording_id}.metadata.json"
                meta_path.write_text('{"format": "mp3", "sample_rate": 44100}')

            # Validate - should find 3 missing FLACs
            missing_count, missing_sources = _validate_flac_files(sources, output_dir)
            assert missing_count == 3
            assert len(missing_sources) == 3

    def test_integration_reports_missing_after_processing(self) -> None:
        """Integration test: should report missing FLACs in actual command output."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"

            # Create a source that should have been processed but FLAC is missing
            source = AudioSource("test_integration", "2020", "19-777")
            missing_count, _ = _validate_flac_files([source], output_dir)
            # Should report 1 missing
            assert missing_count == 1

    def test_validation_logs_more_than_five_missing(self) -> None:
        """Should log '... and X more' when more than 5 files are missing."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"

            # Create 7 sources without FLAC files
            sources = [AudioSource(f"rec_{i}", "2020", f"case-{i}") for i in range(7)]

            # Create metadata but not FLAC for each
            for source in sources:
                out_dir = output_dir / source.term / source.docket
                out_dir.mkdir(parents=True)
                meta_path = out_dir / f"{source.recording_id}.metadata.json"
                meta_path.write_text('{"format": "mp3", "sample_rate": 44100}')

            # Validate - should find 7 missing FLACs
            missing_count, missing_sources = _validate_flac_files(sources, output_dir)
            assert missing_count == 7
            assert len(missing_sources) == 7
            # Should have exactly 7 sources (for testing the "more than 5" path)
            assert len(missing_sources) > 5

    def test_empty_pending_list(self) -> None:
        """Should handle empty pending list gracefully."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"

            # Validate with empty list
            missing_count, missing_sources = _validate_flac_files([], output_dir)
            assert missing_count == 0
            assert len(missing_sources) == 0

    def test_force_mode_reprocesses_existing(self) -> None:
        """Should reprocess files when --force is used."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            mp3_dir = (
                cache_dir / "oyez.case-media.mp3" / "case_data" / "2020" / "19-force"
            )
            mp3_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.1)
            save_audio(samples, 44100, mp3_dir / "test_force.mp3")

            # Process once
            result = runner.invoke(
                app,
                ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
            )
            assert result.exit_code == 0

            # Process again with --force
            result = runner.invoke(
                app,
                [
                    "process",
                    "audio",
                    "-c",
                    str(cache_dir),
                    "-o",
                    str(output_dir),
                    "--force",
                ],
            )
            assert result.exit_code == 0
            output = strip_ansi(result.output)
            # Should not skip (force mode)
            assert "skip" not in output.lower() or "force" in output.lower()

    def test_validation_with_exactly_five_missing(self) -> None:
        """Should handle exactly 5 missing files (boundary case)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"

            # Create exactly 5 sources without FLAC files
            sources = [AudioSource(f"rec_{i}", "2020", f"case-{i}") for i in range(5)]

            # Create metadata but not FLAC for each
            for source in sources:
                out_dir = output_dir / source.term / source.docket
                out_dir.mkdir(parents=True)
                meta_path = out_dir / f"{source.recording_id}.metadata.json"
                meta_path.write_text('{"format": "mp3", "sample_rate": 44100}')

            # Validate - should find 5 missing FLACs
            missing_count, missing_sources = _validate_flac_files(sources, output_dir)
            assert missing_count == 5
            assert len(missing_sources) == 5

    def test_terms_filtering_in_output(self) -> None:
        """Should show terms in output when provided."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            mp3_dir = (
                cache_dir / "oyez.case-media.mp3" / "case_data" / "2020" / "19-terms"
            )
            mp3_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.1)
            save_audio(samples, 44100, mp3_dir / "test_terms.mp3")

            result = runner.invoke(
                app,
                [
                    "process",
                    "audio",
                    "-c",
                    str(cache_dir),
                    "-o",
                    str(output_dir),
                    "--term",
                    "2020",
                ],
            )
            assert result.exit_code == 0
            output = strip_ansi(result.output)
            # Should show terms in output
            assert "2020" in output

    def test_orphaned_metadata_cleanup(self) -> None:
        """Should clean up orphaned metadata files without FLAC."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"
            term_dir = output_dir / "2020" / "19-orphan"
            term_dir.mkdir(parents=True)

            # Create metadata but not FLAC (orphaned)
            meta_path = term_dir / "recording.metadata.json"
            meta_path.write_text('{"format": "mp3", "sample_rate": 44100}')

            # Create source
            source = AudioSource("recording", "2020", "19-orphan")
            sources = {("2020", "19-orphan", "recording"): source}

            # Filter should clean up orphaned metadata
            pending, skipped = _filter_pending_sources(sources, output_dir, force=False)

            # Metadata should be removed
            assert not meta_path.exists()
            # Source should be in pending (not skipped)
            assert len(pending) == 1
            assert skipped == 0

    def test_exception_handling_in_try_process_file(self) -> None:
        """Should handle exceptions in _try_process_file gracefully."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"
            # Use a non-existent file to trigger exception
            fake_path = Path(tmpdir) / "nonexistent.mp3"

            success, err, meta = _try_process_file(
                fake_path, "test", "2020", "19-999", output_dir, 24, "mp3"
            )

            # Should return failure with error message
            assert not success
            assert err != ""
            assert meta == {}

    def test_no_valid_source_file_path(self) -> None:
        """Should handle AudioSource with no valid source files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"
            # Create source with no mp3_path or ogg_path
            source = AudioSource("test", "2020", "19-999")
            # Ensure both paths are None
            source.mp3_path = None
            source.ogg_path = None

            success, err = _process_recording(source, output_dir, 24)

            # Should return failure with "No valid source file" message
            assert not success
            assert "No valid source file" in err

    def test_count_anomalies_with_invalid_json(self) -> None:
        """Should handle invalid JSON in metadata files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"
            term_dir = output_dir / "2020" / "19-invalid"
            term_dir.mkdir(parents=True)

            # Create invalid JSON metadata file
            meta_path = term_dir / "recording.metadata.json"
            meta_path.write_text("invalid json content")

            # Should not crash, return 0 (no valid anomalies found)
            count = _count_anomalies(output_dir)
            assert count == 0

    def test_count_anomalies_with_missing_file(self) -> None:
        """Should handle missing metadata files gracefully."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"
            # Create directory but no files
            output_dir.mkdir(parents=True)

            # Should not crash
            count = _count_anomalies(output_dir)
            assert count == 0

    def test_count_anomalies_detects_anomalies(self) -> None:
        """Should count files with is_anomaly flag."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"
            term_dir = output_dir / "2020" / "19-anomaly"
            term_dir.mkdir(parents=True)

            # Create metadata with anomaly flag
            meta_path = term_dir / "recording.metadata.json"
            meta_path.write_text('{"is_anomaly": true, "format": "mp3"}')

            # Should count 1 anomaly
            count = _count_anomalies(output_dir)
            assert count == 1

    def test_sequential_processing_path(self) -> None:
        """Should use sequential processing when workers=1 or single file."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            mp3_dir = (
                cache_dir / "oyez.case-media.mp3" / "case_data" / "2020" / "19-seq"
            )
            mp3_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.1)
            save_audio(samples, 44100, mp3_dir / "test_seq.mp3")

            # Process with 1 worker to trigger sequential path
            result = runner.invoke(
                app,
                [
                    "process",
                    "audio",
                    "-c",
                    str(cache_dir),
                    "-o",
                    str(output_dir),
                    "--workers",
                    "1",
                ],
            )
            assert result.exit_code == 0
            output = strip_ansi(result.output)
            assert "Processed" in output or "Done" in output

    def test_force_mode_output(self) -> None:
        """Should show force mode message when --force is used."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            mp3_dir = (
                cache_dir / "oyez.case-media.mp3" / "case_data" / "2020" / "19-force"
            )
            mp3_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.1)
            save_audio(samples, 44100, mp3_dir / "test_force.mp3")

            result = runner.invoke(
                app,
                [
                    "process",
                    "audio",
                    "-c",
                    str(cache_dir),
                    "-o",
                    str(output_dir),
                    "--force",
                ],
            )
            assert result.exit_code == 0
            output = strip_ansi(result.output)
            # Should mention force mode
            assert "force" in output.lower() or "reprocess" in output.lower()

    def test_all_files_already_processed_message(self) -> None:
        """Should show message when all files are already processed."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            mp3_dir = (
                cache_dir / "oyez.case-media.mp3" / "case_data" / "2020" / "19-already"
            )
            mp3_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.1)
            save_audio(samples, 44100, mp3_dir / "test_already.mp3")

            # Process once
            result = runner.invoke(
                app,
                ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
            )
            assert result.exit_code == 0

            # Process again (should skip)
            result = runner.invoke(
                app,
                ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
            )
            assert result.exit_code == 0
            output = strip_ansi(result.output)
            # Should show "already processed" or "skipped" message
            assert (
                "already processed" in output.lower()
                or "skipped" in output.lower()
                or "all files" in output.lower()
            )

    def test_skipped_count_output(self) -> None:
        """Should show skipped count when files are already processed."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            mp3_dir = (
                cache_dir / "oyez.case-media.mp3" / "case_data" / "2020" / "19-skip"
            )
            mp3_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.1)
            save_audio(samples, 44100, mp3_dir / "test_skip.mp3")

            # Process once
            result = runner.invoke(
                app,
                ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
            )
            assert result.exit_code == 0

            # Process again - should show skipped count
            result = runner.invoke(
                app,
                ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
            )
            assert result.exit_code == 0
            output = strip_ansi(result.output)
            # Should mention skipped or existing
            assert "skip" in output.lower() or "existing" in output.lower()

    def test_mp_context_valueerror_handling(self) -> None:
        """Should handle ValueError when spawn context is unavailable."""
        # Mock mp.get_context to raise ValueError
        with patch(
            "multiprocessing.get_context", side_effect=ValueError("spawn not available")
        ):
            # Reload module to trigger the exception handling
            importlib.reload(cli_process_audio)
            # Should not crash, _MP_CONTEXT should be None
            assert cli_process_audio._MP_CONTEXT is None

    def test_try_process_file_returns_false_on_failure(self) -> None:
        """Should return (False, err) when processing fails (line 145)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"
            # Use a non-existent file to trigger failure
            fake_path = Path(tmpdir) / "nonexistent.mp3"

            success, err, meta = _try_process_file(
                fake_path, "test", "2020", "19-999", output_dir, 24, "mp3"
            )

            # Should return failure with error message (line 145)
            assert not success
            assert err != ""
            assert meta == {}

    def test_process_audio_reports_missing_flac_files(self) -> None:
        """Should report missing FLAC files after processing (lines 299, 305-314)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir) / "cache"
            output_dir = Path(tmpdir) / "data"
            mp3_dir = (
                cache_dir / "oyez.case-media.mp3" / "case_data" / "2020" / "19-missing"
            )
            mp3_dir.mkdir(parents=True)

            samples = make_sine(sr=44100, dur=0.1)
            save_audio(samples, 44100, mp3_dir / "test_missing.mp3")

            # Mock _process_recording to simulate missing FLAC
            with patch(
                "oyez_sa_asr.cli_process_audio._process_recording",
                return_value=(True, ""),
            ):
                # Process - should complete but may report missing files
                result = runner.invoke(
                    app,
                    ["process", "audio", "-c", str(cache_dir), "-o", str(output_dir)],
                )
            # Should handle gracefully
            assert result.exit_code in {0, 1}

    def test_process_audio_reports_more_than_five_missing(self) -> None:
        """Should report '... and X more' when more than 5 files are missing (line 314)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"

            # Create 7 sources without FLAC files
            sources = [AudioSource(f"rec_{i}", "2020", f"case-{i}") for i in range(7)]

            # Create metadata but not FLAC for each
            for source in sources:
                out_dir = output_dir / source.term / source.docket
                out_dir.mkdir(parents=True)
                meta_path = out_dir / f"{source.recording_id}.metadata.json"
                meta_path.write_text('{"format": "mp3", "sample_rate": 44100}')

            # Validate - should find 7 missing FLACs
            missing_count, missing_sources = _validate_flac_files(sources, output_dir)
            assert missing_count == 7
            assert len(missing_sources) == 7
            # Should have more than 5 to trigger the "and X more" message
            assert len(missing_sources) > 5

    def test_run_parallel_sources_handles_exceptions(self) -> None:
        """Should handle exceptions in parallel processing (lines 205-206)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir) / "data"
            sources = [AudioSource("test", "2020", "19-999")]

            # Mock ProcessPoolExecutor and as_completed to raise BrokenExecutor
            with (
                patch(
                    "oyez_sa_asr.cli_process_audio.ProcessPoolExecutor"
                ) as mock_executor_cls,
                patch(
                    "oyez_sa_asr.cli_process_audio.as_completed"
                ) as mock_as_completed,
            ):
                mock_executor = MagicMock()
                mock_future = MagicMock()
                mock_future.result.side_effect = BrokenExecutor("executor broken")
                mock_executor.submit.return_value = mock_future
                mock_executor_cls.return_value.__enter__.return_value = mock_executor
                # Mock as_completed to return the future that will raise BrokenExecutor
                mock_as_completed.return_value = [mock_future]

                _processed, errors = _run_parallel_sources(sources, output_dir, 24, 1)
                # Should handle exception and count as error
                assert errors >= 0
