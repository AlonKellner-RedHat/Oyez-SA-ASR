# Generated by Claude
"""Tests for scrape audio command and extract_audio_urls."""

import json
import re
import tempfile
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch

from typer.testing import CliRunner

from oyez_sa_asr.cli import app
from oyez_sa_asr.cli_scrape_audio import _is_expected_skip
from oyez_sa_asr.scraper.models import FetchResult
from oyez_sa_asr.scraper.parser_transcripts import extract_audio_urls


def strip_ansi(text: str) -> str:
    """Strip ANSI escape codes from text."""
    return re.sub(r"\x1b\[[0-9;]*m", "", text)


runner = CliRunner()


class TestExtractAudioUrls:
    """Tests for extract_audio_urls function."""

    def test_extracts_all_formats(self) -> None:
        """Extract mp3, ogg, and hls URLs from transcripts."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            term_dir = transcripts_dir / "2022" / "21-476"
            term_dir.mkdir(parents=True)

            transcript = {
                "metadata": {
                    "audio_urls": {
                        "mp3": "https://s3.amazonaws.com/bucket/audio.mp3",
                        "ogg": "https://s3.amazonaws.com/bucket/audio.ogg",
                        "hls": "https://s3.amazonaws.com/bucket/audio.m3u8",
                    }
                }
            }
            (term_dir / "oral_argument.json").write_text(json.dumps(transcript))

            urls = extract_audio_urls(transcripts_dir)

            assert len(urls) == 3
            assert "https://s3.amazonaws.com/bucket/audio.mp3" in urls
            assert "https://s3.amazonaws.com/bucket/audio.ogg" in urls
            assert "https://s3.amazonaws.com/bucket/audio.m3u8" in urls

    def test_empty_directory(self) -> None:
        """Return empty list for empty directory."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            transcripts_dir.mkdir()

            urls = extract_audio_urls(transcripts_dir)
            assert urls == []

    def test_nonexistent_directory(self) -> None:
        """Return empty list for nonexistent directory."""
        urls = extract_audio_urls(Path("/nonexistent/path"))
        assert urls == []

    def test_deduplicates_urls(self) -> None:
        """Deduplicate URLs across multiple transcripts."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            term_dir = transcripts_dir / "2022" / "21-476"
            term_dir.mkdir(parents=True)

            # Same URL in multiple files
            transcript = {
                "metadata": {
                    "audio_urls": {
                        "mp3": "https://s3.amazonaws.com/bucket/shared.mp3",
                    }
                }
            }
            (term_dir / "file1.json").write_text(json.dumps(transcript))
            (term_dir / "file2.json").write_text(json.dumps(transcript))

            urls = extract_audio_urls(transcripts_dir)
            assert len(urls) == 1


class TestScrapeAudioCommand:
    """Tests for scrape audio CLI command."""

    def test_help(self) -> None:
        """Show help for scrape audio command."""
        result = runner.invoke(app, ["scrape", "audio", "--help"])
        assert result.exit_code == 0
        output = strip_ansi(result.output)
        assert "--transcripts-dir" in output
        assert "--cache-dir" in output
        assert "--max-parallelism" in output

    def test_empty_transcripts(self) -> None:
        """Handle empty transcripts directory gracefully."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            transcripts_dir.mkdir()
            cache_dir = Path(tmpdir) / "cache"

            result = runner.invoke(
                app,
                [
                    "scrape",
                    "audio",
                    "--transcripts-dir",
                    str(transcripts_dir),
                    "--cache-dir",
                    str(cache_dir),
                ],
            )

            assert result.exit_code == 0
            assert "No audio URLs found" in result.output

    @patch("oyez_sa_asr.cli_scrape_audio.AdaptiveFetcher")
    @patch("oyez_sa_asr.cli_scrape_audio.extract_audio_urls")
    def test_fetches_urls(
        self, mock_extract: MagicMock, mock_fetcher_cls: MagicMock
    ) -> None:
        """Extract URLs and use AdaptiveFetcher to download them."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            transcripts_dir.mkdir()
            cache_dir = Path(tmpdir) / "cache"

            # Mock URL extraction
            mock_extract.return_value = [
                "https://s3.amazonaws.com/bucket/audio1.mp3",
                "https://s3.amazonaws.com/bucket/audio2.mp3",
            ]

            # Mock fetcher
            mock_fetcher = mock_fetcher_cls.create_s3.return_value
            mock_fetcher.fetch_batch_adaptive = AsyncMock(return_value=[])

            result = runner.invoke(
                app,
                [
                    "scrape",
                    "audio",
                    "--transcripts-dir",
                    str(transcripts_dir),
                    "--cache-dir",
                    str(cache_dir),
                ],
            )

            assert result.exit_code == 0
            mock_extract.assert_called_once_with(transcripts_dir, None)
            mock_fetcher_cls.create_s3.assert_called_once()
            mock_fetcher.fetch_batch_adaptive.assert_called_once()

    def test_is_expected_skip_checks_error_string(self) -> None:
        """Should check error string for expected skip conditions (lines 26-27)."""
        # Test NoSuchKey in error string
        result = FetchResult(
            url="https://example.com/test.mp3",
            success=False,
            error="NoSuchKey: The specified key does not exist",
        )
        assert _is_expected_skip(result) is True

        # Test AccessDenied in error string
        result = FetchResult(
            url="https://example.com/test.mp3",
            success=False,
            error="AccessDenied: Access Denied",
        )
        assert _is_expected_skip(result) is True

        # Test Unrecognized S3 URL in error string
        result = FetchResult(
            url="https://example.com/test.mp3",
            success=False,
            error="Unrecognized S3 URL",
        )
        assert _is_expected_skip(result) is True

    def test_scrape_audio_with_terms_and_force(self) -> None:
        """Should display terms and force mode messages (lines 80, 84)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            transcripts_dir.mkdir()
            cache_dir = Path(tmpdir) / "cache"

            with patch(
                "oyez_sa_asr.cli_scrape_audio.extract_audio_urls"
            ) as mock_extract:
                mock_extract.return_value = []
                result = runner.invoke(
                    app,
                    [
                        "scrape",
                        "audio",
                        "--transcripts-dir",
                        str(transcripts_dir),
                        "--cache-dir",
                        str(cache_dir),
                        "--term",
                        "2024",
                        "--force",
                    ],
                )
                output = strip_ansi(result.output)
                assert "Terms: 2024" in output
                assert "Force mode" in output

    def test_scrape_transcripts_with_terms_and_force(self) -> None:
        """Should display terms and force mode messages (lines 64, 69)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cases_dir = Path(tmpdir) / "cases"
            cases_dir.mkdir()
            cache_dir = Path(tmpdir) / "cache"

            with patch(
                "oyez_sa_asr.cli_scrape_transcripts.extract_media_urls"
            ) as mock_extract:
                mock_extract.return_value = []
                result = runner.invoke(
                    app,
                    [
                        "scrape",
                        "transcripts",
                        "--cases-dir",
                        str(cases_dir),
                        "--cache-dir",
                        str(cache_dir),
                        "--term",
                        "2024",
                        "--force",
                    ],
                )
                output = strip_ansi(result.output)
                assert "Terms: 2024" in output
                assert "Force mode" in output

    def test_extract_audio_urls_skips_non_directories(self) -> None:
        """Should skip non-directory entries (lines 201, 203, 249, 251, 255)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            transcripts_dir.mkdir()

            # Create a file (not a directory) in transcripts_dir
            (transcripts_dir / "not_a_dir.txt").write_text("test")

            # Create a valid term directory with a file (not a directory) inside
            term_dir = transcripts_dir / "2024"
            term_dir.mkdir()
            (term_dir / "not_a_dir.json").write_text("test")

            # Create a valid docket directory
            docket_dir = term_dir / "22-123"
            docket_dir.mkdir()
            transcript = {
                "metadata": {"audio_urls": {"mp3": "https://example.com/test.mp3"}}
            }
            (docket_dir / "transcript.json").write_text(json.dumps(transcript))

            urls = extract_audio_urls(transcripts_dir)
            # Should only extract from valid directories, skip non-directories
            assert len(urls) == 1

    def test_extract_audio_urls_handles_exceptions(self) -> None:
        """Should handle JSONDecodeError, KeyError, TypeError (lines 221-222, 269-270)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            term_dir = transcripts_dir / "2024" / "22-123"
            term_dir.mkdir(parents=True)

            # Create invalid JSON file
            (term_dir / "invalid.json").write_text("{ invalid json }")

            # Create file with missing keys
            incomplete = {"type": "oral_argument"}  # Missing metadata
            (term_dir / "incomplete.json").write_text(json.dumps(incomplete))

            # Create valid transcript
            transcript = {
                "metadata": {"audio_urls": {"mp3": "https://example.com/test.mp3"}}
            }
            (term_dir / "valid.json").write_text(json.dumps(transcript))

            urls = extract_audio_urls(transcripts_dir)
            # Should handle exceptions gracefully and only extract from valid file
            assert len(urls) == 1

    def test_scrape_audio_on_progress_callback(self) -> None:
        """Should call on_progress callback during downloading (lines 119-138)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            cache_dir = Path(tmpdir) / "cache"
            term_dir = transcripts_dir / "2024" / "22-123"
            term_dir.mkdir(parents=True)
            transcript = {
                "metadata": {
                    "audio_urls": {
                        "mp3": "https://s3.amazonaws.com/bucket/audio.mp3",
                    }
                }
            }
            (term_dir / "oral_argument.json").write_text(json.dumps(transcript))

            with patch(
                "oyez_sa_asr.cli_scrape_audio.AdaptiveFetcher"
            ) as mock_fetcher_cls:
                mock_fetcher = mock_fetcher_cls.create_s3.return_value
                mock_fetcher.fetch_batch_adaptive = AsyncMock(return_value=[])

                result = runner.invoke(
                    app,
                    [
                        "scrape",
                        "audio",
                        "--transcripts-dir",
                        str(transcripts_dir),
                        "--cache-dir",
                        str(cache_dir),
                    ],
                )

                assert result.exit_code == 0
                # Should have called fetch_batch_adaptive with on_progress
                mock_fetcher.fetch_batch_adaptive.assert_called_once()
                call_args = mock_fetcher.fetch_batch_adaptive.call_args
                # on_progress is passed as second positional argument
                assert len(call_args[0]) >= 2, (
                    "on_progress should be passed as positional arg"
                )
                assert callable(call_args[0][1]), (
                    "Second positional arg should be callable (on_progress)"
                )
                call_args[1] if len(call_args) > 1 else {}

    def test_scrape_audio_reports_errors(self) -> None:
        """Should report errors when errors > 0 (line 175)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            transcripts_dir = Path(tmpdir) / "transcripts"
            cache_dir = Path(tmpdir) / "cache"
            term_dir = transcripts_dir / "2024" / "22-123"
            term_dir.mkdir(parents=True)
            transcript = {
                "metadata": {
                    "audio_urls": {
                        "mp3": "https://s3.amazonaws.com/bucket/audio.mp3",
                    }
                }
            }
            (term_dir / "oral_argument.json").write_text(json.dumps(transcript))

            with patch(
                "oyez_sa_asr.cli_scrape_audio.AdaptiveFetcher"
            ) as mock_fetcher_cls:
                mock_fetcher = mock_fetcher_cls.create_s3.return_value
                # Return a result with an error
                error_result = FetchResult(
                    url="https://s3.amazonaws.com/bucket/audio.mp3",
                    success=False,
                    error="Network error",
                )
                mock_fetcher.fetch_batch_adaptive = AsyncMock(
                    return_value=[error_result]
                )

                result = runner.invoke(
                    app,
                    [
                        "scrape",
                        "audio",
                        "--transcripts-dir",
                        str(transcripts_dir),
                        "--cache-dir",
                        str(cache_dir),
                    ],
                )

                output = strip_ansi(result.output)
                # Should report errors
                assert "Error" in output or "error" in output.lower()
