# Generated by Claude
"""Tests for loaders module."""

import os
from pathlib import Path

import pyarrow as pa
import pyarrow.parquet as pq
import pytest

from oyez_sa_asr.loaders import extract_segment, load_flex, load_raw, load_simple


class TestLoadRaw:
    """Tests for load_raw function."""

    def test_returns_list_of_items(self, tmp_path: Path) -> None:
        """Returns list of recording items."""
        (tmp_path / "audio").mkdir()
        (tmp_path / "transcripts").mkdir()
        (tmp_path / "cases").mkdir()

        result = load_raw(tmp_path)

        assert isinstance(result, list)

    def test_finds_audio_files_with_expected_keys(self, tmp_path: Path) -> None:
        """Finds MP3 and OGG files and returns items with expected keys."""
        audio_dir = tmp_path / "audio" / "2024" / "22-1"
        audio_dir.mkdir(parents=True)
        (audio_dir / "test_recording.delivery.mp3").touch()
        (audio_dir / "test_recording.ogg").touch()
        (tmp_path / "transcripts").mkdir()
        (tmp_path / "cases").mkdir()

        result = load_raw(tmp_path)

        assert len(result) == 1
        item = result[0]
        assert item["recording_id"] == "test_recording"
        assert item["term"] == "2024"
        assert item["docket"] == "22-1"
        assert item["audio_path"] is not None
        assert item["audio_ogg_path"] is not None
        assert "transcript_path" in item
        assert "case_path" in item


class TestLoadFlex:
    """Tests for load_flex function."""

    def test_returns_empty_when_no_files(self, tmp_path: Path) -> None:
        """Returns empty lists when parquet files don't exist."""
        (tmp_path / "data").mkdir()
        recordings, utterances = load_flex(tmp_path)
        assert recordings == []
        assert utterances == []

    def test_loads_recordings_and_utterances(self, tmp_path: Path) -> None:
        """Loads data from parquet files."""
        data_dir = tmp_path / "data"
        data_dir.mkdir()

        recs = [{"term": "2024", "docket": "22-1"}]
        pq.write_table(pa.Table.from_pylist(recs), data_dir / "recordings.parquet")

        utts = [{"text": "hello", "speaker_name": "Test"}]
        pq.write_table(pa.Table.from_pylist(utts), data_dir / "utterances.parquet")

        recordings, utterances = load_flex(tmp_path)

        assert len(recordings) == 1
        assert len(utterances) == 1


class TestLoadSimple:
    """Tests for load_simple function."""

    def test_returns_empty_when_no_splits(self, tmp_path: Path) -> None:
        """Returns empty list when no splits exist."""
        result = load_simple("lt1m", tmp_path)
        assert result == []

    def test_loads_parquet_data(self, tmp_path: Path) -> None:
        """Loads data from parquet files."""
        split_dir = tmp_path / "lt1m" / "data" / "utterances"
        split_dir.mkdir(parents=True)

        data = [{"id": "1", "sentence": "hello", "speaker": "Test"}]
        pq.write_table(pa.Table.from_pylist(data), split_dir / "train-00000.parquet")

        result = load_simple("lt1m", tmp_path)

        assert len(result) == 1
        assert result[0]["sentence"] == "hello"
        assert result[0]["_split"] == "lt1m"

    def test_loads_all_splits(self, tmp_path: Path) -> None:
        """Loads from all splits when split='all'."""
        for split in ["lt1m", "lt5m"]:
            split_dir = tmp_path / split / "data" / "utterances"
            split_dir.mkdir(parents=True)
            data = [{"id": split, "sentence": f"text_{split}"}]
            pq.write_table(
                pa.Table.from_pylist(data), split_dir / "train-00000.parquet"
            )

        result = load_simple("all", tmp_path)
        assert len(result) == 2


class TestExtractSegment:
    """Tests for extract_segment function."""

    def test_raises_on_invalid_range(self, tmp_path: Path) -> None:
        """Raises ValueError when start >= end."""
        with pytest.raises(ValueError, match="must be less than"):
            extract_segment(tmp_path / "test.flac", 5.0, 3.0)


class TestLoadRawErrorHandling:
    """Tests for error handling in load_raw function."""

    def test_handles_invalid_json_in_cases(self, tmp_path: Path) -> None:
        """Should handle invalid JSON files in cases directory gracefully."""
        (tmp_path / "audio").mkdir()
        (tmp_path / "transcripts").mkdir()
        (tmp_path / "cases").mkdir()

        # Create invalid JSON file
        (tmp_path / "cases" / "invalid.json").write_text("{ invalid json }")

        # Should not raise, just skip the invalid file
        result = load_raw(tmp_path)
        assert isinstance(result, list)

    def test_handles_oserror_in_cases(self, tmp_path: Path) -> None:
        """Should handle OSError when reading case files gracefully."""
        (tmp_path / "audio").mkdir()
        (tmp_path / "transcripts").mkdir()
        (tmp_path / "cases").mkdir()

        # Create a case file that will cause OSError (e.g., permission denied)
        case_file = tmp_path / "cases" / "test.json"
        case_file.write_text('{"term": "2024", "docket_number": "22-1"}')

        # Make it unreadable (on Unix systems)
        if hasattr(os, "chmod"):
            os.chmod(case_file, 0o000)
            try:
                result = load_raw(tmp_path)
                assert isinstance(result, list)
            finally:
                # Restore permissions for cleanup
                os.chmod(case_file, 0o644)
        else:
            # On Windows or systems without chmod, just test that it doesn't crash
            result = load_raw(tmp_path)
            assert isinstance(result, list)

    def test_handles_missing_term_or_docket_in_case(self, tmp_path: Path) -> None:
        """Should skip cases with missing term or docket."""
        (tmp_path / "audio").mkdir()
        (tmp_path / "transcripts").mkdir()
        (tmp_path / "cases").mkdir()

        # Create case file without term
        (tmp_path / "cases" / "no_term.json").write_text('{"docket_number": "22-1"}')

        # Create case file without docket
        (tmp_path / "cases" / "no_docket.json").write_text('{"term": "2024"}')

        result = load_raw(tmp_path)
        assert isinstance(result, list)

    def test_handles_invalid_json_in_transcripts(self, tmp_path: Path) -> None:
        """Should handle invalid JSON files in transcripts directory gracefully."""
        (tmp_path / "audio").mkdir()
        (tmp_path / "transcripts").mkdir()
        (tmp_path / "cases").mkdir()

        # Create invalid JSON file
        (tmp_path / "transcripts" / "invalid.json").write_text("{ invalid json }")

        # Should not raise, just skip the invalid file
        result = load_raw(tmp_path)
        assert isinstance(result, list)

    def test_handles_oserror_in_transcripts(self, tmp_path: Path) -> None:
        """Should handle OSError when reading transcript files gracefully."""
        (tmp_path / "audio").mkdir()
        (tmp_path / "transcripts").mkdir()
        (tmp_path / "cases").mkdir()

        # Create a transcript file that will cause OSError
        transcript_file = tmp_path / "transcripts" / "test.json"
        transcript_file.write_text('{"media_file": [{"href": "test.mp3"}]}')

        # Make it unreadable (on Unix systems)
        if hasattr(os, "chmod"):
            os.chmod(transcript_file, 0o000)
            try:
                result = load_raw(tmp_path)
                assert isinstance(result, list)
            finally:
                # Restore permissions for cleanup
                os.chmod(transcript_file, 0o644)
        else:
            # On Windows or systems without chmod, just test that it doesn't crash
            result = load_raw(tmp_path)
            assert isinstance(result, list)

    def test_handles_malformed_media_file_structure(self, tmp_path: Path) -> None:
        """Should handle transcript files with malformed media_file structure."""
        (tmp_path / "audio").mkdir()
        (tmp_path / "transcripts").mkdir()
        (tmp_path / "cases").mkdir()

        # Create transcript with None media_file (handled by "or []")
        (tmp_path / "transcripts" / "null_media.json").write_text(
            '{"media_file": null}'
        )

        # Create transcript with empty media_file list
        (tmp_path / "transcripts" / "empty_media.json").write_text('{"media_file": []}')

        # Create transcript with media_file item missing href
        (tmp_path / "transcripts" / "no_href.json").write_text(
            '{"media_file": [{"not_href": "test"}]}'
        )

        # Create transcript with empty href (should be skipped)
        (tmp_path / "transcripts" / "empty_href.json").write_text(
            '{"media_file": [{"href": ""}]}'
        )

        result = load_raw(tmp_path)
        assert isinstance(result, list)

    def test_handles_empty_href_in_media_file(self, tmp_path: Path) -> None:
        """Should skip media_file items with empty href."""
        (tmp_path / "audio").mkdir()
        (tmp_path / "transcripts").mkdir()
        (tmp_path / "cases").mkdir()

        # Create transcript with empty href
        (tmp_path / "transcripts" / "empty_href.json").write_text(
            '{"media_file": [{"href": ""}]}'
        )

        result = load_raw(tmp_path)
        assert isinstance(result, list)
