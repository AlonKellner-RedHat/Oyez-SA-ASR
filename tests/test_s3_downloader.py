# Generated by Claude
"""Tests for S3 downloader and URL parsing."""

import tempfile
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock

import pytest
from botocore.exceptions import ClientError

from oyez_sa_asr.scraper.models import FetchResult, RequestMetadata
from oyez_sa_asr.scraper.s3_downloader import S3Downloader, parse_s3_url


class TestParseS3Url:
    """Tests for parse_s3_url function."""

    def test_path_style_url(self) -> None:
        """Parse path-style S3 URL."""
        url = (
            "https://s3.amazonaws.com/oyez.case-media.mp3/"
            "case_data/2022/21-476/audio.mp3"
        )
        bucket, key = parse_s3_url(url)
        assert bucket == "oyez.case-media.mp3"
        assert key == "case_data/2022/21-476/audio.mp3"

    def test_virtual_hosted_style_url(self) -> None:
        """Parse virtual-hosted-style S3 URL."""
        url = "https://mybucket.s3.amazonaws.com/path/to/file.mp3"
        bucket, key = parse_s3_url(url)
        assert bucket == "mybucket"
        assert key == "path/to/file.mp3"

    def test_invalid_url_raises(self) -> None:
        """Raise ValueError for unrecognized URL format."""
        with pytest.raises(ValueError, match="Unrecognized S3 URL format"):
            parse_s3_url("https://example.com/file.mp3")


class TestS3Downloader:
    """Tests for S3Downloader class."""

    def test_check_cache_returns_none_when_not_cached(self) -> None:
        """Return None when file is not in cache."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir)
            downloader = S3Downloader(cache_dir)

            request = RequestMetadata(
                url="https://s3.amazonaws.com/bucket/path/file.mp3"
            )
            result = downloader.check_cache(request)
            assert result is None

    def test_check_cache_returns_result_when_cached(self) -> None:
        """Return FetchResult when file exists in cache."""
        with tempfile.TemporaryDirectory() as tmpdir:
            cache_dir = Path(tmpdir)
            downloader = S3Downloader(cache_dir)

            # Create cached file
            cached_path = cache_dir / "bucket" / "path" / "file.mp3"
            cached_path.parent.mkdir(parents=True)
            cached_path.write_bytes(b"audio data")

            request = RequestMetadata(
                url="https://s3.amazonaws.com/bucket/path/file.mp3"
            )
            result = downloader.check_cache(request)

            assert result is not None
            assert result.success is True
            assert result.from_cache is True
            assert str(cached_path) in str(result.data)

    def test_is_transient_failure(self) -> None:
        """Identify transient S3 errors."""
        with tempfile.TemporaryDirectory() as tmpdir:
            downloader = S3Downloader(Path(tmpdir))

            # Success is not transient
            assert not downloader.is_transient_failure(
                FetchResult(url="x", success=True)
            )

            # 503 is transient
            assert downloader.is_transient_failure(
                FetchResult(url="x", success=False, status_code=503)
            )

            # 404 is not transient
            assert not downloader.is_transient_failure(
                FetchResult(url="x", success=False, status_code=404)
            )

            # None status (connection error) is transient
            assert downloader.is_transient_failure(
                FetchResult(url="x", success=False, status_code=None)
            )


class TestS3DownloaderFetch:
    """Tests for S3Downloader fetch method."""

    @pytest.mark.asyncio
    async def test_fetch_invalid_url(self) -> None:
        """Return error for invalid S3 URL."""
        with tempfile.TemporaryDirectory() as tmpdir:
            downloader = S3Downloader(Path(tmpdir))

            request = RequestMetadata(url="https://example.com/not-s3")

            # Mock client - won't be used for invalid URL
            mock_client = MagicMock()

            result = await downloader.fetch(mock_client, request)

            assert result.success is False
            assert "Unrecognized S3 URL format" in str(result.error)

    @pytest.mark.asyncio
    async def test_fetch_success(self) -> None:
        """Successfully download file from S3."""
        with tempfile.TemporaryDirectory() as tmpdir:
            downloader = S3Downloader(Path(tmpdir))

            request = RequestMetadata(
                url="https://s3.amazonaws.com/bucket/path/file.mp3"
            )

            # Mock S3 response
            mock_body = AsyncMock()
            mock_body.read = AsyncMock(return_value=b"audio content")
            mock_body.__aenter__ = AsyncMock(return_value=mock_body)
            mock_body.__aexit__ = AsyncMock(return_value=None)

            mock_client = MagicMock()
            mock_client.get_object = AsyncMock(
                return_value={
                    "Body": mock_body,
                    "ContentType": "audio/mpeg",
                }
            )

            result = await downloader.fetch(mock_client, request)

            assert result.success is True
            assert result.from_cache is False
            assert "bucket/path/file.mp3" in str(result.data)

            # Verify file was written
            local_path = Path(tmpdir) / "bucket" / "path" / "file.mp3"
            assert local_path.exists()
            assert local_path.read_bytes() == b"audio content"

    @pytest.mark.asyncio
    async def test_fetch_client_error(self) -> None:
        """Handle S3 client errors gracefully."""
        with tempfile.TemporaryDirectory() as tmpdir:
            downloader = S3Downloader(Path(tmpdir))

            request = RequestMetadata(url="https://s3.amazonaws.com/bucket/missing.mp3")

            mock_client = MagicMock()
            mock_client.get_object = AsyncMock(
                side_effect=ClientError(
                    {
                        "Error": {"Code": "NoSuchKey"},
                        "ResponseMetadata": {"HTTPStatusCode": 404},
                    },
                    "GetObject",
                )
            )

            result = await downloader.fetch(mock_client, request)

            assert result.success is False
            assert result.status_code == 404
            assert "NoSuchKey" in str(result.error)

    @pytest.mark.asyncio
    async def test_create_client(self) -> None:
        """Create S3 client with anonymous access."""
        with tempfile.TemporaryDirectory() as tmpdir:
            downloader = S3Downloader(Path(tmpdir))

            async with downloader.create_client() as client:
                # Client should be created successfully
                assert client is not None

    def test_check_unavailable_handles_exceptions(self) -> None:
        """Should handle JSONDecodeError and KeyError (lines 124-126)."""
        # Note: The method is _check_unavailable_cache (private), tested via check_cache
        with tempfile.TemporaryDirectory() as tmpdir:
            downloader = S3Downloader(Path(tmpdir))
            request = RequestMetadata(
                url="https://s3.amazonaws.com/bucket/path/file.mp3"
            )
            unavailable_path = downloader._get_unavailable_path(request)
            unavailable_path.parent.mkdir(parents=True, exist_ok=True)

            # Test JSONDecodeError
            unavailable_path.write_text("{ invalid json }")
            result = downloader._check_unavailable_cache(request)
            assert result is None
            assert not unavailable_path.exists()  # Should be deleted

            # Test missing error key - method uses .get() so no KeyError is raised
            # It returns a FetchResult with error=None
            unavailable_path.parent.mkdir(parents=True, exist_ok=True)
            unavailable_path.write_text('{"status_code": 404}')  # Missing error
            result = downloader._check_unavailable_cache(request)
            # Should return a result (no KeyError because .get() is used)
            assert result is not None
            assert result.status_code == 404
            assert result.error is None  # Missing key becomes None

    def test_check_cache_handles_invalid_url(self) -> None:
        """Should return None for invalid S3 URL (lines 132-133)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            downloader = S3Downloader(Path(tmpdir))
            request = RequestMetadata(url="https://example.com/not-s3")
            result = downloader.check_cache(request)
            assert result is None
