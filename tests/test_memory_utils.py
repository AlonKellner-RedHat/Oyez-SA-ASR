# Generated by Claude
"""Tests for memory_utils module (OOM detection and orphan cleanup)."""

import subprocess
from unittest.mock import MagicMock, patch

from oyez_sa_asr.memory_utils import (
    get_memory_usage_mb,
    get_oom_kill_count,
    kill_orphan_workers,
    set_pdeathsig,
)


class TestSetPdeathsig:
    """Tests for set_pdeathsig function."""

    def test_set_pdeathsig_runs_without_error(self) -> None:
        """Verify set_pdeathsig runs without raising on Linux."""
        # Should not raise - either succeeds or logs debug message
        set_pdeathsig()

    def test_set_pdeathsig_handles_missing_libc(self) -> None:
        """Verify set_pdeathsig handles missing libc gracefully."""
        with patch("ctypes.CDLL") as mock_cdll:
            mock_cdll.side_effect = OSError("libc not found")
            # Should not raise, just log debug message
            set_pdeathsig()

    def test_set_pdeathsig_handles_prctl_failure(self) -> None:
        """Verify set_pdeathsig handles prctl failure gracefully."""
        mock_libc = MagicMock()
        mock_libc.prctl.return_value = -1  # Simulate failure
        with patch("ctypes.CDLL", return_value=mock_libc):
            # Should not raise, just log warning
            set_pdeathsig()


class TestKillOrphanWorkers:
    """Tests for kill_orphan_workers function."""

    def test_kill_orphan_workers_handles_missing_pkill(self) -> None:
        """Verify kill_orphan_workers handles missing pkill gracefully."""
        with patch("subprocess.run") as mock_run:
            mock_run.side_effect = FileNotFoundError("pkill not found")
            result = kill_orphan_workers()
            assert result == 0  # No processes killed

    def test_kill_orphan_workers_handles_subprocess_error(self) -> None:
        """Verify kill_orphan_workers handles subprocess errors gracefully."""
        with patch("subprocess.run") as mock_run:
            mock_run.side_effect = subprocess.SubprocessError("error")
            result = kill_orphan_workers()
            assert result == 0

    def test_kill_orphan_workers_counts_killed_patterns(self) -> None:
        """Verify kill_orphan_workers returns count of killed pattern types."""
        with patch("subprocess.run") as mock_run:
            # Simulate: first pattern killed, second not found, third killed
            mock_run.side_effect = [
                MagicMock(returncode=0),  # forkserver killed
                MagicMock(returncode=1),  # resource_tracker not found
                MagicMock(returncode=0),  # semaphore_tracker killed
            ]
            result = kill_orphan_workers()
            assert result == 2  # Two pattern types had processes killed

    def test_kill_orphan_workers_no_processes_found(self) -> None:
        """Verify kill_orphan_workers returns 0 when no orphans exist."""
        with patch("subprocess.run") as mock_run:
            # All pkill calls return 1 (no matching processes)
            mock_run.return_value = MagicMock(returncode=1)
            result = kill_orphan_workers()
            assert result == 0


class TestGetOomKillCount:
    """Tests for get_oom_kill_count function."""

    def test_get_oom_kill_count_handles_missing_file(self) -> None:
        """Verify get_oom_kill_count returns 0 when cgroup file missing."""
        with patch("pathlib.Path.exists", return_value=False):
            result = get_oom_kill_count()
            assert result == 0

    def test_get_oom_kill_count_parses_correctly(self) -> None:
        """Verify get_oom_kill_count parses cgroup file correctly."""
        mock_content = "low 0\nhigh 0\nmax 0\noom 0\noom_kill 5\noom_group_kill 0\n"
        with (
            patch("pathlib.Path.exists", return_value=True),
            patch("pathlib.Path.read_text", return_value=mock_content),
        ):
            result = get_oom_kill_count()
            assert result == 5


class TestGetMemoryUsageMb:
    """Tests for get_memory_usage_mb function."""

    def test_get_memory_usage_mb_handles_missing_free(self) -> None:
        """Verify get_memory_usage_mb returns zeros when free unavailable."""
        with patch("subprocess.run") as mock_run:
            mock_run.side_effect = FileNotFoundError("free not found")
            result = get_memory_usage_mb()
            assert result == (0, 0, 0)

    def test_get_memory_usage_mb_parses_output(self) -> None:
        """Verify get_memory_usage_mb parses free output correctly."""
        mock_output = (
            "              total        used        free      shared  "
            "buff/cache   available\n"
            "Mem:          16000        8000        2000         500        "
            "5500       10000\n"
        )
        with patch("subprocess.run") as mock_run:
            mock_run.return_value = MagicMock(stdout=mock_output, returncode=0)
            used, available, total = get_memory_usage_mb()
            assert total == 16000
            assert used == 8000
            assert available == 10000
