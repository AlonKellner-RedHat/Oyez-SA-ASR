# Generated by Claude
"""Tests for audio_source module."""

from pathlib import Path

from oyez_sa_asr.audio_source import (
    extract_term_docket,
    extract_transcript_date,
    find_audio_sources,
    get_preferred_format,
    get_recording_id,
    get_recording_id_from_transcript,
    get_source_era,
    parse_date_from_recording_id,
    parse_date_from_title,
    parse_transcript_type_from_recording_id,
)


class TestParseTranscriptTypeFromRecordingId:
    """Tests for parse_transcript_type_from_recording_id function.

    Edited by Claude: Added tests for audio-transcript type matching fix.
    """

    def test_modern_argument(self) -> None:
        """Parses oral_argument from modern format."""
        assert (
            parse_transcript_type_from_recording_id("21-86_20221107-argument")
            == "oral_argument"
        )

    def test_modern_opinion(self) -> None:
        """Parses opinion from modern format."""
        assert (
            parse_transcript_type_from_recording_id("22-166_20230525-opinion")
            == "opinion"
        )

    def test_modern_opinion_dissent(self) -> None:
        """Parses dissent from modern format."""
        assert (
            parse_transcript_type_from_recording_id("21-476_20230630-opinion-dissent")
            == "dissent"
        )

    def test_modern_opinion_concurrence(self) -> None:
        """Parses concurrence from modern format."""
        assert (
            parse_transcript_type_from_recording_id(
                "20-1199_20230629-opinion-concurrence"
            )
            == "concurrence"
        )

    def test_modern_opinion_concur(self) -> None:
        """Parses concurrence from concur variant."""
        assert (
            parse_transcript_type_from_recording_id("23-726_20240627-opinion-concur")
            == "concurrence"
        )

    def test_legacy_argument(self) -> None:
        """Parses oral_argument from legacy format (a suffix)."""
        assert (
            parse_transcript_type_from_recording_id("20000418a_99-224")
            == "oral_argument"
        )

    def test_legacy_opinion(self) -> None:
        """Parses opinion from legacy format (o suffix)."""
        assert parse_transcript_type_from_recording_id("20000619o_99-224") == "opinion"

    def test_legacy_reargument(self) -> None:
        """Parses oral_argument from legacy reargument (r suffix)."""
        assert (
            parse_transcript_type_from_recording_id("20000329r_98-6322")
            == "oral_argument"
        )

    def test_unknown_format(self) -> None:
        """Returns unknown for unrecognized format."""
        assert parse_transcript_type_from_recording_id("random-id") == "unknown"

    def test_empty_string(self) -> None:
        """Returns unknown for empty string."""
        assert parse_transcript_type_from_recording_id("") == "unknown"


class TestParseDateFromRecordingId:
    """Tests for parse_date_from_recording_id (deterministic date from URL)."""

    def test_modern_argument(self) -> None:
        """Parses date from modern format."""
        assert parse_date_from_recording_id("19-1392_20211201-argument") == (
            2021,
            12,
            1,
        )

    def test_modern_opinion(self) -> None:
        """Parses date from modern opinion."""
        assert parse_date_from_recording_id("22-166_20230525-opinion") == (
            2023,
            5,
            25,
        )

    def test_legacy_argument(self) -> None:
        """Parses date from legacy format (YYYYMMDD at start)."""
        assert parse_date_from_recording_id("19951010a_94-1039") == (1995, 10, 10)

    def test_legacy_reargument(self) -> None:
        """Parses date from legacy reargument."""
        assert parse_date_from_recording_id("19551013r_3") == (1955, 10, 13)

    def test_unknown_format_returns_none(self) -> None:
        """Returns None for unrecognized format."""
        assert parse_date_from_recording_id("random-id") is None

    def test_empty_returns_none(self) -> None:
        """Returns None for empty string."""
        assert parse_date_from_recording_id("") is None


class TestGetRecordingIdFromTranscript:
    """Tests for get_recording_id_from_transcript."""

    def test_modern_mp3_url(self) -> None:
        """Extracts recording_id from modern mp3 URL."""
        t = {
            "metadata": {
                "audio_urls": {
                    "mp3": "https://s3.../19-1392_20211201-argument.delivery.mp3",
                },
            },
        }
        assert get_recording_id_from_transcript(t) == "19-1392_20211201-argument"

    def test_legacy_mp3_url(self) -> None:
        """Extracts recording_id from legacy mp3 URL."""
        t = {
            "metadata": {
                "audio_urls": {
                    "mp3": "https://s3.../19951010a_94-1039.delivery.mp3",
                },
            },
        }
        assert get_recording_id_from_transcript(t) == "19951010a_94-1039"

    def test_missing_audio_urls_returns_none(self) -> None:
        """Returns None when metadata.audio_urls missing."""
        assert get_recording_id_from_transcript({"metadata": {}}) is None

    def test_missing_mp3_returns_none(self) -> None:
        """Returns None when mp3 URL missing."""
        t = {"metadata": {"audio_urls": {"ogg": "https://..."}}}
        assert get_recording_id_from_transcript(t) is None


class TestParseDateFromTitle:
    """Tests for parse_date_from_title."""

    def test_dash_format(self) -> None:
        """Parses 'Oral Argument - December 01, 2021'."""
        assert parse_date_from_title("Oral Argument - December 01, 2021") == (
            2021,
            12,
            1,
        )

    def test_comma_format(self) -> None:
        """Parses 'Oral Argument, March 23, 2015' (no dash before date)."""
        assert parse_date_from_title("Oral Argument, March 23, 2015") == (
            2015,
            3,
            23,
        )

    def test_opinion_announcement(self) -> None:
        """Parses 'Opinion Announcement - May 20, 1996'."""
        assert parse_date_from_title("Opinion Announcement - May 20, 1996") == (
            1996,
            5,
            20,
        )

    def test_no_date_returns_none(self) -> None:
        """Returns None when title has no date."""
        assert parse_date_from_title("Wisconsin v. Yoder - Life of the Law") is None

    def test_empty_returns_none(self) -> None:
        """Returns None for empty or None."""
        assert parse_date_from_title("") is None
        assert parse_date_from_title(None) is None  # type: ignore[arg-type]


class TestExtractTranscriptDate:
    """Tests for extract_transcript_date."""

    def test_modern_transcript(self) -> None:
        """Extracts date from transcript with modern URL."""
        t = {
            "metadata": {
                "audio_urls": {
                    "mp3": "https://s3.../19-1392_20211201-argument.delivery.mp3",
                },
            },
        }
        assert extract_transcript_date(t) == (2021, 12, 1)

    def test_legacy_transcript(self) -> None:
        """Extracts date from transcript with legacy URL."""
        t = {
            "metadata": {
                "audio_urls": {
                    "mp3": "https://s3.../19951010a_94-1039.delivery.mp3",
                },
            },
        }
        assert extract_transcript_date(t) == (1995, 10, 10)

    def test_no_audio_urls_returns_none(self) -> None:
        """Returns None when transcript has no audio_urls."""
        assert extract_transcript_date({"metadata": {}}) is None


class TestGetRecordingId:
    """Tests for get_recording_id function."""

    def test_strips_delivery_suffix(self) -> None:
        """Strips .delivery suffix from MP3 files."""
        path = Path("audio.delivery.mp3")
        assert get_recording_id(path) == "audio"

    def test_keeps_normal_stem(self) -> None:
        """Keeps stem for normal files."""
        path = Path("20240101a_22-123.ogg")
        assert get_recording_id(path) == "20240101a_22-123"


class TestGetPreferredFormat:
    """Tests for get_preferred_format function."""

    def test_digital_era_prefers_mp3(self) -> None:
        """Post-2005 terms prefer MP3."""
        assert get_preferred_format("2010") == ("mp3", "ogg")

    def test_analog_era_prefers_ogg(self) -> None:
        """Pre-2006 terms prefer OGG."""
        assert get_preferred_format("2000") == ("ogg", "mp3")

    def test_invalid_term_defaults_to_mp3(self) -> None:
        """Invalid term defaults to MP3."""
        assert get_preferred_format("invalid") == ("mp3", "ogg")


class TestGetSourceEra:
    """Tests for get_source_era function."""

    def test_digital_era(self) -> None:
        """Post-2005 terms are digital."""
        assert get_source_era("2010") == "digital"

    def test_analog_era(self) -> None:
        """Pre-2006 terms are analog."""
        assert get_source_era("2000") == "analog"

    def test_invalid_term_returns_unknown(self) -> None:
        """Invalid term returns unknown."""
        assert get_source_era("invalid") == "unknown"


class TestExtractTermDocket:
    """Tests for extract_term_docket function."""

    def test_extracts_from_valid_path(self) -> None:
        """Extracts term and docket from valid path."""
        path = Path("/cache/oyez.case-media.mp3/case_data/2024/22-123/audio.mp3")
        assert extract_term_docket(path) == ("2024", "22-123")

    def test_returns_none_for_invalid_path(self) -> None:
        """Returns None for paths without case_data."""
        path = Path("/cache/audio/2024/22-123/audio.mp3")
        assert extract_term_docket(path) is None

    def test_returns_none_for_short_path(self) -> None:
        """Returns None for paths too short after case_data."""
        path = Path("/cache/case_data/2024")
        assert extract_term_docket(path) is None


class TestFindAudioSources:
    """Tests for find_audio_sources function."""

    def test_finds_mp3_files(self, tmp_path: Path) -> None:
        """Finds MP3 files in cache."""
        mp3_dir = tmp_path / "oyez.case-media.mp3" / "case_data" / "2024" / "22-123"
        mp3_dir.mkdir(parents=True)
        (mp3_dir / "audio.delivery.mp3").write_bytes(b"mp3")

        sources = find_audio_sources(tmp_path)
        assert len(sources) == 1
        assert ("2024", "22-123", "audio") in sources

    def test_filters_by_term(self, tmp_path: Path) -> None:
        """Filters sources by term."""
        for term in ["2023", "2024"]:
            mp3_dir = tmp_path / "oyez.case-media.mp3" / "case_data" / term / "docket"
            mp3_dir.mkdir(parents=True)
            (mp3_dir / "audio.mp3").write_bytes(b"mp3")

        sources = find_audio_sources(tmp_path, ["2024"])
        assert len(sources) == 1
        assert ("2024", "docket", "audio") in sources

    def test_combines_mp3_and_ogg(self, tmp_path: Path) -> None:
        """Combines MP3 and OGG for same recording."""
        for fmt in ["mp3", "ogg"]:
            fmt_dir = (
                tmp_path / f"oyez.case-media.{fmt}" / "case_data" / "2024" / "22-123"
            )
            fmt_dir.mkdir(parents=True)
            if fmt == "mp3":
                (fmt_dir / "audio.delivery.mp3").write_bytes(b"mp3")
            else:
                (fmt_dir / "audio.ogg").write_bytes(b"ogg")

        sources = find_audio_sources(tmp_path)
        assert len(sources) == 1
        source = sources[("2024", "22-123", "audio")]
        assert source.mp3_path is not None
        assert source.ogg_path is not None
