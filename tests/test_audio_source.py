# Generated by Claude
"""Tests for audio_source module."""

from pathlib import Path

from oyez_sa_asr.audio_source import (
    extract_term_docket,
    find_audio_sources,
    get_preferred_format,
    get_recording_id,
    get_source_era,
    parse_transcript_type_from_recording_id,
)


class TestParseTranscriptTypeFromRecordingId:
    """Tests for parse_transcript_type_from_recording_id function.

    Edited by Claude: Added tests for audio-transcript type matching fix.
    """

    def test_modern_argument(self) -> None:
        """Parses oral_argument from modern format."""
        assert (
            parse_transcript_type_from_recording_id("21-86_20221107-argument")
            == "oral_argument"
        )

    def test_modern_opinion(self) -> None:
        """Parses opinion from modern format."""
        assert (
            parse_transcript_type_from_recording_id("22-166_20230525-opinion")
            == "opinion"
        )

    def test_modern_opinion_dissent(self) -> None:
        """Parses dissent from modern format."""
        assert (
            parse_transcript_type_from_recording_id("21-476_20230630-opinion-dissent")
            == "dissent"
        )

    def test_modern_opinion_concurrence(self) -> None:
        """Parses concurrence from modern format."""
        assert (
            parse_transcript_type_from_recording_id(
                "20-1199_20230629-opinion-concurrence"
            )
            == "concurrence"
        )

    def test_modern_opinion_concur(self) -> None:
        """Parses concurrence from concur variant."""
        assert (
            parse_transcript_type_from_recording_id("23-726_20240627-opinion-concur")
            == "concurrence"
        )

    def test_legacy_argument(self) -> None:
        """Parses oral_argument from legacy format (a suffix)."""
        assert (
            parse_transcript_type_from_recording_id("20000418a_99-224")
            == "oral_argument"
        )

    def test_legacy_opinion(self) -> None:
        """Parses opinion from legacy format (o suffix)."""
        assert parse_transcript_type_from_recording_id("20000619o_99-224") == "opinion"

    def test_legacy_reargument(self) -> None:
        """Parses oral_argument from legacy reargument (r suffix)."""
        assert (
            parse_transcript_type_from_recording_id("20000329r_98-6322")
            == "oral_argument"
        )

    def test_unknown_format(self) -> None:
        """Returns unknown for unrecognized format."""
        assert parse_transcript_type_from_recording_id("random-id") == "unknown"

    def test_empty_string(self) -> None:
        """Returns unknown for empty string."""
        assert parse_transcript_type_from_recording_id("") == "unknown"


class TestGetRecordingId:
    """Tests for get_recording_id function."""

    def test_strips_delivery_suffix(self) -> None:
        """Strips .delivery suffix from MP3 files."""
        path = Path("audio.delivery.mp3")
        assert get_recording_id(path) == "audio"

    def test_keeps_normal_stem(self) -> None:
        """Keeps stem for normal files."""
        path = Path("20240101a_22-123.ogg")
        assert get_recording_id(path) == "20240101a_22-123"


class TestGetPreferredFormat:
    """Tests for get_preferred_format function."""

    def test_digital_era_prefers_mp3(self) -> None:
        """Post-2005 terms prefer MP3."""
        assert get_preferred_format("2010") == ("mp3", "ogg")

    def test_analog_era_prefers_ogg(self) -> None:
        """Pre-2006 terms prefer OGG."""
        assert get_preferred_format("2000") == ("ogg", "mp3")

    def test_invalid_term_defaults_to_mp3(self) -> None:
        """Invalid term defaults to MP3."""
        assert get_preferred_format("invalid") == ("mp3", "ogg")


class TestGetSourceEra:
    """Tests for get_source_era function."""

    def test_digital_era(self) -> None:
        """Post-2005 terms are digital."""
        assert get_source_era("2010") == "digital"

    def test_analog_era(self) -> None:
        """Pre-2006 terms are analog."""
        assert get_source_era("2000") == "analog"

    def test_invalid_term_returns_unknown(self) -> None:
        """Invalid term returns unknown."""
        assert get_source_era("invalid") == "unknown"


class TestExtractTermDocket:
    """Tests for extract_term_docket function."""

    def test_extracts_from_valid_path(self) -> None:
        """Extracts term and docket from valid path."""
        path = Path("/cache/oyez.case-media.mp3/case_data/2024/22-123/audio.mp3")
        assert extract_term_docket(path) == ("2024", "22-123")

    def test_returns_none_for_invalid_path(self) -> None:
        """Returns None for paths without case_data."""
        path = Path("/cache/audio/2024/22-123/audio.mp3")
        assert extract_term_docket(path) is None

    def test_returns_none_for_short_path(self) -> None:
        """Returns None for paths too short after case_data."""
        path = Path("/cache/case_data/2024")
        assert extract_term_docket(path) is None


class TestFindAudioSources:
    """Tests for find_audio_sources function."""

    def test_finds_mp3_files(self, tmp_path: Path) -> None:
        """Finds MP3 files in cache."""
        mp3_dir = tmp_path / "oyez.case-media.mp3" / "case_data" / "2024" / "22-123"
        mp3_dir.mkdir(parents=True)
        (mp3_dir / "audio.delivery.mp3").write_bytes(b"mp3")

        sources = find_audio_sources(tmp_path)
        assert len(sources) == 1
        assert ("2024", "22-123", "audio") in sources

    def test_filters_by_term(self, tmp_path: Path) -> None:
        """Filters sources by term."""
        for term in ["2023", "2024"]:
            mp3_dir = tmp_path / "oyez.case-media.mp3" / "case_data" / term / "docket"
            mp3_dir.mkdir(parents=True)
            (mp3_dir / "audio.mp3").write_bytes(b"mp3")

        sources = find_audio_sources(tmp_path, ["2024"])
        assert len(sources) == 1
        assert ("2024", "docket", "audio") in sources

    def test_combines_mp3_and_ogg(self, tmp_path: Path) -> None:
        """Combines MP3 and OGG for same recording."""
        for fmt in ["mp3", "ogg"]:
            fmt_dir = (
                tmp_path / f"oyez.case-media.{fmt}" / "case_data" / "2024" / "22-123"
            )
            fmt_dir.mkdir(parents=True)
            if fmt == "mp3":
                (fmt_dir / "audio.delivery.mp3").write_bytes(b"mp3")
            else:
                (fmt_dir / "audio.ogg").write_bytes(b"ogg")

        sources = find_audio_sources(tmp_path)
        assert len(sources) == 1
        source = sources[("2024", "22-123", "audio")]
        assert source.mp3_path is not None
        assert source.ogg_path is not None
